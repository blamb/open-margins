<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Nova — Experimental OER Lab · TRU Open Press</title>
<script>(function(){var t=localStorage.getItem('om-theme')||(window.matchMedia('(prefers-color-scheme: dark)').matches?'dark':'light');document.documentElement.setAttribute('data-theme',t);})();</script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Fraunces:ital,wght@0,400;0,600;0,700;1,400;1,600&family=DM+Sans:wght@300;400;500;600&family=DM+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>
/* ══════════════════════════════════════════════════════════
   NOVA — Experimental OER Learning Lab
   TRU Open Press · Five radical activity types
   ══════════════════════════════════════════════════════════ */

:root {
  --void: #09090f;
  --deep: #0d0d1a;
  --panel: #12121f;
  --surface: #1a1a2e;
  --surface-hi: #20203a;
  --border: rgba(255,255,255,0.07);
  --border-hi: rgba(255,255,255,0.14);

  --gold: #f5a623;
  --gold-dim: rgba(245,166,35,0.15);
  --gold-glow: rgba(245,166,35,0.4);
  --teal: #00d4aa;
  --teal-dim: rgba(0,212,170,0.12);
  --violet: #a78bfa;
  --violet-dim: rgba(167,139,250,0.12);
  --rose: #fb7185;
  --rose-dim: rgba(251,113,133,0.12);
  --sky: #38bdf8;
  --sky-dim: rgba(56,189,248,0.12);

  --text: #e8e8f0;
  --text-dim: #8888aa;
  --text-faint: #7878a8;

  --navy: #003865;
  --navy-mid: #00498a;

  --r: 12px;
  --r-sm: 8px;
  --transition: 0.22s cubic-bezier(0.4, 0, 0.2, 1);
  --glow-gold: 0 0 24px rgba(245,166,35,0.25), 0 0 60px rgba(245,166,35,0.08);
  --glow-teal: 0 0 24px rgba(0,212,170,0.2), 0 0 60px rgba(0,212,170,0.06);
}

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
html { font-size: 15px; scroll-behavior: smooth; }
/* Focus ring — keyboard users only, overrides outline:none on inputs/buttons */
:focus-visible { outline: 2px solid #f5a623; outline-offset: 2px; border-radius: 3px; }

body {
  font-family: 'DM Sans', system-ui, sans-serif;
  background: var(--void);
  color: var(--text);
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  overflow-x: hidden;
}

/* ── SCROLLBAR ── */
::-webkit-scrollbar { width: 5px; height: 5px; }
::-webkit-scrollbar-track { background: var(--deep); }
::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.12); border-radius: 3px; }

/* ── TOPBAR ── */
.topbar {
  background: rgba(9,9,15,0.92);
  backdrop-filter: blur(12px);
  border-bottom: 1px solid var(--border);
  padding: 0 24px;
  height: 56px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  position: sticky;
  top: 0;
  z-index: 200;
  flex-shrink: 0;
}

.topbar-brand {
  display: flex;
  align-items: center;
  gap: 14px;
}

.topbar-logo {
  height: 36px;
  width: 36px;
  object-fit: contain;
  filter: drop-shadow(0 0 8px rgba(245,166,35,0.3));
}

.brand-text { display: flex; flex-direction: column; }

.brand-nova {
  font-family: 'Fraunces', serif;
  font-size: 1.2rem;
  font-weight: 700;
  color: var(--gold);
  line-height: 1;
  letter-spacing: -0.01em;
}

.brand-sub {
  font-size: 0.65rem;
  color: var(--gold);
  letter-spacing: 0.06em;
  text-transform: uppercase;
  margin-top: 1px;
}

.topbar-right {
  display: flex;
  align-items: center;
  gap: 10px;
}

.status-pill {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px 12px;
  border-radius: 20px;
  font-size: 0.68rem;
  font-weight: 600;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  background: var(--surface);
  border: 1px solid var(--border);
  color: var(--text-dim);
  transition: all var(--transition);
}
.status-pill.connected { border-color: rgba(0,212,170,0.4); color: var(--teal); }
.status-dot { width: 6px; height: 6px; border-radius: 50%; background: currentColor; }
.status-pill.connected .status-dot { box-shadow: 0 0 6px currentColor; animation: pulse 2s infinite; }
@keyframes pulse { 0%,100%{opacity:1} 50%{opacity:0.5} }

.topbar-lab-badge {
  padding: 4px 12px;
  border-radius: 20px;
  font-size: 0.65rem;
  font-weight: 700;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  background: linear-gradient(135deg, rgba(167,139,250,0.2), rgba(245,166,35,0.2));
  border: 1px solid rgba(167,139,250,0.3);
  color: var(--violet);
}

/* ── APP SHELL ── */
.app-shell {
  display: flex;
  flex: 1;
  height: calc(100vh - 56px - 34px); /* topbar 56px + suite-nav 34px */
  overflow: hidden;
}

/* ── LEFT PANEL (Context) ── */
.context-panel {
  width: 300px;
  background: var(--panel);
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  flex-shrink: 0;
  transition: width var(--transition);
}

.context-header {
  padding: 18px 18px 14px;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}

.section-label {
  font-size: 0.6rem;
  font-weight: 700;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  color: var(--text-dim);
  margin-bottom: 10px;
}

.proxy-row {
  display: flex;
  gap: 6px;
  align-items: center;
  margin-bottom: 8px;
}

.proxy-input {
  flex: 1;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 7px 10px;
  font-family: 'DM Mono', monospace;
  font-size: 0.7rem;
  color: var(--text);
  outline: none;
  transition: border-color var(--transition);
}
.proxy-input:focus { border-color: rgba(245,166,35,0.5); }

.btn-connect {
  padding: 7px 12px;
  background: var(--gold-dim);
  border: 1px solid rgba(245,166,35,0.3);
  border-radius: 6px;
  color: var(--gold);
  font-family: 'DM Sans', sans-serif;
  font-size: 0.72rem;
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition);
  white-space: nowrap;
}
.btn-connect:hover { background: rgba(245,166,35,0.25); }

.context-body {
  flex: 1;
  overflow-y: auto;
  padding: 14px 18px;
}

.text-area-label {
  font-size: 0.68rem;
  font-weight: 600;
  color: var(--text-dim);
  letter-spacing: 0.04em;
  margin-bottom: 6px;
  display: block;
}

.oer-textarea {
  width: 100%;
  min-height: 200px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 12px;
  font-family: 'DM Sans', sans-serif;
  font-size: 0.8rem;
  line-height: 1.6;
  color: var(--text);
  resize: vertical;
  outline: none;
  transition: border-color var(--transition);
}
.oer-textarea:focus { border-color: rgba(245,166,35,0.4); }
.oer-textarea::placeholder { color: var(--text-dim); }

.word-count {
  font-size: 0.65rem;
  color: var(--text-dim);
  text-align: right;
  margin-top: 4px;
}

.context-divider {
  height: 1px;
  background: var(--border);
  margin: 16px 0;
}

.objective-input {
  width: 100%;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 8px 10px;
  font-family: 'DM Sans', sans-serif;
  font-size: 0.8rem;
  color: var(--text);
  outline: none;
  transition: border-color var(--transition);
}
.objective-input:focus { border-color: rgba(245,166,35,0.4); }
.objective-input::placeholder { color: var(--text-dim); }

/* ── CENTRE (Activity Selector + Stage) ── */
.centre {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* ── ACTIVITY RIBBON ── */
.activity-ribbon {
  display: flex;
  gap: 6px;
  padding: 12px 16px;
  border-bottom: 1px solid var(--border);
  background: var(--panel);
  overflow-x: auto;
  flex-shrink: 0;
}
.activity-ribbon::-webkit-scrollbar { height: 0; }

.activity-tile {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  padding: 10px 14px;
  border-radius: 10px;
  cursor: pointer;
  border: 1px solid var(--border);
  background: var(--surface);
  transition: all var(--transition);
  white-space: nowrap;
  min-width: 110px;
  font-family: 'DM Sans', sans-serif;
}
.activity-tile:hover {
  border-color: var(--border-hi);
  background: var(--surface-hi);
}
.activity-tile.active {
  border-color: var(--tile-color, var(--gold));
  background: var(--tile-bg, var(--gold-dim));
  box-shadow: 0 0 20px var(--tile-glow, var(--gold-glow));
}

.tile-icon { font-size: 1.4rem; line-height: 1; }
.tile-name {
  font-size: 0.7rem;
  font-weight: 600;
  color: var(--text-dim);
  letter-spacing: 0.02em;
}
.activity-tile.active .tile-name { color: var(--tile-color, var(--gold)); }
.tile-tag {
  font-size: 0.55rem;
  font-weight: 700;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  color: var(--tile-color, var(--gold));
  opacity: 0.7;
}

/* ── STAGE ── */
.stage {
  flex: 1;
  overflow-y: auto;
  position: relative;
}

.stage-idle {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  padding: 40px;
  text-align: center;
  gap: 20px;
}

.idle-nova-mark {
  font-family: 'Fraunces', serif;
  font-size: 5rem;
  font-weight: 700;
  color: var(--gold);
  opacity: 0.12;
  letter-spacing: -0.04em;
  user-select: none;
}

.idle-title {
  font-family: 'Fraunces', serif;
  font-size: 1.5rem;
  font-weight: 600;
  color: var(--text);
  max-width: 480px;
  line-height: 1.3;
}

.idle-sub {
  font-size: 0.88rem;
  color: var(--text-dim);
  max-width: 420px;
  line-height: 1.7;
}

.idle-quote {
  font-family: 'Fraunces', serif;
  font-style: italic;
  font-size: 0.88rem;
  color: var(--text-dim);
  line-height: 1.65;
  max-width: 460px;
  border-left: 2px solid rgba(245,166,35,0.3);
  padding-left: 16px;
  text-align: left;
  margin: 0;
}
.idle-attr {
  font-size: 0.63rem;
  color: var(--text-faint);
  letter-spacing: 0.05em;
  margin-top: -10px;
  text-align: left;
  max-width: 460px;
  padding-left: 18px;
}

.idle-tiles {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  justify-content: center;
  max-width: 520px;
  margin-top: 10px;
}

.idle-tile-hint {
  padding: 6px 14px;
  border-radius: 20px;
  font-size: 0.75rem;
  border: 1px solid var(--border-hi);
  color: var(--text-dim);
  background: var(--surface);
}

/* ── GENERATE BAR ── */
.generate-bar {
  padding: 12px 16px;
  border-top: 1px solid var(--border);
  background: var(--panel);
  flex-shrink: 0;
}

.generate-bar-inner {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.generate-btn-row {
  display: flex;
  gap: 8px;
  align-items: stretch;
}

.btn-regenerate {
  flex-shrink: 0;
  width: 42px;
  background: var(--surface);
  border: 1px solid var(--border-hi);
  border-radius: 9px;
  color: var(--text-dim);
  font-size: 1.1rem;
  cursor: pointer;
  transition: all var(--transition);
  display: flex;
  align-items: center;
  justify-content: center;
}
.btn-regenerate:hover {
  background: var(--surface-hi);
  color: var(--gold);
  border-color: rgba(245,166,35,0.4);
  transform: rotate(45deg);
}
.btn-regenerate.hidden { display: none; }

.generate-hint {
  font-size: 0.68rem;
  color: var(--rose);
  text-align: center;
  min-height: 1em;
  transition: opacity var(--transition);
  letter-spacing: 0.02em;
}
.generate-hint:empty,
.generate-hint.hidden { opacity: 0; pointer-events: none; }

.btn-generate {
  flex: 1;
  padding: 12px 20px;
  background: linear-gradient(135deg, var(--navy) 0%, var(--navy-mid) 100%);
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: 9px;
  color: #fff;
  font-family: 'DM Sans', sans-serif;
  font-size: 0.9rem;
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition);
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  letter-spacing: 0.01em;
  position: relative;
  overflow: hidden;
}
.btn-generate::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, rgba(245,166,35,0.15), rgba(0,212,170,0.1));
  opacity: 0;
  transition: opacity var(--transition);
}
.btn-generate:hover::before { opacity: 1; }
.btn-generate:hover { transform: translateY(-1px); box-shadow: 0 6px 20px rgba(0,56,101,0.4); }
.btn-generate:disabled { opacity: 0.35; cursor: not-allowed; transform: none; }

.btn-generate .spark { font-size: 1rem; }

/* ── GENERATING OVERLAY ── */
.generating-overlay {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 400px;
  gap: 20px;
  padding: 60px;
}

.nova-spinner {
  width: 60px;
  height: 60px;
  position: relative;
}
.nova-spinner::before, .nova-spinner::after {
  content: '';
  position: absolute;
  border-radius: 50%;
  border: 2px solid transparent;
}
.nova-spinner::before {
  inset: 0;
  border-top-color: var(--gold);
  animation: spin 1s linear infinite;
}
.nova-spinner::after {
  inset: 8px;
  border-top-color: var(--teal);
  animation: spin 0.7s linear infinite reverse;
}
@keyframes spin { to { transform: rotate(360deg); } }

.gen-title {
  font-family: 'Fraunces', serif;
  font-size: 1.2rem;
  color: var(--text);
  opacity: 0.8;
}
.gen-sub { font-size: 0.82rem; color: var(--text-dim); text-align: center; max-width: 340px; line-height: 1.6; }

/* ── ERROR STATE ── */
.error-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 300px;
  gap: 14px;
  padding: 40px;
  text-align: center;
}
.error-icon { font-size: 2.5rem; opacity: 0.5; }
.error-title { font-size: 1rem; font-weight: 600; color: var(--rose); }
.error-msg { font-size: 0.82rem; color: var(--text-dim); max-width: 380px; line-height: 1.6; }

/* ══════════════════════════════════════════════════════════
   ACTIVITY 1: CONCEPT MAP (SVG)
   ══════════════════════════════════════════════════════════ */

.concept-map-wrap {
  padding: 20px;
  display: flex;
  flex-direction: column;
  gap: 16px;
  min-height: 100%;
}

.map-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex-wrap: wrap;
  gap: 10px;
  flex-shrink: 0;
}

.map-title {
  font-family: 'Fraunces', serif;
  font-size: 1.1rem;
  font-weight: 600;
  color: var(--text);
}

.map-controls {
  display: flex;
  gap: 8px;
  align-items: center;
}

.btn-map-ctrl {
  padding: 5px 12px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 6px;
  color: var(--text-dim);
  font-family: 'DM Sans', sans-serif;
  font-size: 0.72rem;
  font-weight: 500;
  cursor: pointer;
  transition: all var(--transition);
}
.btn-map-ctrl:hover { border-color: var(--border-hi); color: var(--text); }
.btn-map-ctrl.active { border-color: var(--gold); color: var(--gold); background: rgba(245,166,35,0.08); }

/* Map body: SVG + optional detail panel side-by-side */
.map-body {
  display: flex;
  gap: 14px;
  flex: 1;
  min-height: 0;
}

#concept-svg-container {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 14px;
  overflow: hidden;
  position: relative;
  min-height: 480px;
  flex: 1;
  cursor: grab;
  user-select: none;
  touch-action: none;
}
#concept-svg-container:active { cursor: grabbing; }
#concept-svg-container.panning { cursor: grabbing; }

#concept-svg {
  width: 100%;
  height: 100%;
  display: block;
  min-height: 480px;
}

/* Zoom hint overlay */
.map-zoom-hint {
  position: absolute;
  bottom: 10px;
  right: 12px;
  font-size: 0.62rem;
  color: rgba(255,255,255,0.2);
  pointer-events: none;
  letter-spacing: 0.03em;
}

/* Zoom controls */
.map-zoom-btns {
  position: absolute;
  bottom: 10px;
  left: 12px;
  display: flex;
  flex-direction: column;
  gap: 4px;
}
.btn-zoom {
  width: 26px; height: 26px;
  background: rgba(255,255,255,0.07);
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: 6px;
  color: rgba(255,255,255,0.5);
  font-size: 1rem;
  line-height: 1;
  cursor: pointer;
  display: flex; align-items: center; justify-content: center;
  transition: all 0.15s;
}
.btn-zoom:hover { background: rgba(255,255,255,0.13); color: #fff; }

/* Node dim/focus states */
.map-node { transition: opacity 0.2s; }
.map-node.dimmed { opacity: 0.12; }
.map-node.focused ellipse { stroke-width: 3 !important; }
.map-node.neighbour ellipse { stroke-width: 2.2 !important; }

.map-edge { transition: opacity 0.2s, stroke-width 0.2s; }
.map-edge.dimmed { opacity: 0.06; }
.map-edge.highlighted { stroke-opacity: 0.9 !important; stroke-width: 2.5 !important; }
.map-edge-label { transition: opacity 0.2s; }
.map-edge-label.dimmed { opacity: 0.05; }
.map-edge-label.highlighted { opacity: 1 !important; font-weight: 700; }

/* Legend — filterable */
.map-legend {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  flex-shrink: 0;
}
.legend-item {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 0.72rem;
  color: var(--text-dim);
  cursor: pointer;
  padding: 3px 8px;
  border-radius: 20px;
  border: 1px solid transparent;
  transition: all 0.15s;
  user-select: none;
}
.legend-item:hover { border-color: var(--border-hi); color: var(--text); }
.legend-item.filter-off { opacity: 0.35; }
.legend-item.filter-active { border-color: var(--border-hi); color: var(--text); background: rgba(255,255,255,0.05); }
.legend-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  flex-shrink: 0;
}

/* Detail side panel */
.map-detail-panel {
  width: 0;
  overflow: hidden;
  transition: width 0.25s cubic-bezier(0.4,0,0.2,1);
  flex-shrink: 0;
  display: flex;
  flex-direction: column;
}
.map-detail-panel.open {
  width: 240px;
}
.map-detail-inner {
  width: 240px;
  background: var(--panel);
  border: 1px solid var(--border-hi);
  border-radius: 14px;
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  height: 100%;
  min-height: 480px;
  box-sizing: border-box;
}
.map-detail-type {
  font-size: 0.62rem;
  font-weight: 700;
  letter-spacing: 0.09em;
  text-transform: uppercase;
}
.map-detail-name {
  font-family: 'Fraunces', serif;
  font-size: 1rem;
  font-weight: 600;
  color: var(--text);
  line-height: 1.3;
}
.map-detail-summary {
  font-size: 0.8rem;
  color: var(--text-dim);
  line-height: 1.6;
  flex: 1;
}
.map-detail-connections {
  border-top: 1px solid var(--border);
  padding-top: 10px;
}
.map-detail-conn-label {
  font-size: 0.62rem;
  font-weight: 700;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: var(--text-dim);
  margin-bottom: 6px;
}
.map-detail-conn-item {
  font-size: 0.75rem;
  color: var(--text-dim);
  padding: 4px 0;
  border-bottom: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.map-detail-conn-item:last-child { border-bottom: none; }
.map-detail-conn-rel {
  font-size: 0.65rem;
  opacity: 0.6;
  font-style: italic;
}
.map-detail-close {
  align-self: flex-end;
  background: none;
  border: none;
  color: var(--text-dim);
  cursor: pointer;
  font-size: 1rem;
  line-height: 1;
  padding: 0;
  margin-bottom: -4px;
}
.map-detail-close:hover { color: var(--text); }

.node-tooltip {
  position: fixed;
  background: var(--panel);
  border: 1px solid var(--border-hi);
  border-radius: 10px;
  padding: 10px 14px;
  font-size: 0.78rem;
  color: var(--text);
  max-width: 260px;
  line-height: 1.5;
  pointer-events: none;
  z-index: 500;
  box-shadow: 0 8px 30px rgba(0,0,0,0.5);
  opacity: 0;
  transition: opacity 0.15s;
}
.node-tooltip.visible { opacity: 1; }
.node-tooltip-title { font-weight: 600; margin-bottom: 4px; }

/* ══════════════════════════════════════════════════════════
   ACTIVITY 2: SOCRATIC TUTOR
   ══════════════════════════════════════════════════════════ */

.socratic-wrap {
  display: flex;
  flex-direction: column;
  height: 100%;
}

.socratic-messages {
  flex: 1;
  overflow-y: auto;
  padding: 24px 20px;
  display: flex;
  flex-direction: column;
  gap: 18px;
}

.message {
  display: flex;
  gap: 12px;
  max-width: 100%;
  animation: fadeSlideIn 0.3s ease;
}

@keyframes fadeSlideIn {
  from { opacity: 0; transform: translateY(8px); }
  to { opacity: 1; transform: translateY(0); }
}

.message.tutor { align-self: flex-start; }
.message.student { align-self: flex-end; flex-direction: row-reverse; }

.msg-avatar {
  width: 34px;
  height: 34px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1rem;
  flex-shrink: 0;
  margin-top: 2px;
}
.tutor .msg-avatar { background: var(--gold-dim); border: 1px solid rgba(245,166,35,0.3); }
.student .msg-avatar { background: var(--teal-dim); border: 1px solid rgba(0,212,170,0.3); }

.msg-bubble {
  max-width: 480px;
  padding: 12px 16px;
  border-radius: 14px;
  font-size: 0.88rem;
  line-height: 1.65;
  position: relative;
}
.tutor .msg-bubble {
  background: var(--surface);
  border: 1px solid var(--border);
  border-top-left-radius: 4px;
  color: var(--text);
}
.student .msg-bubble {
  background: var(--teal-dim);
  border: 1px solid rgba(0,212,170,0.25);
  border-top-right-radius: 4px;
  color: var(--text);
}

.msg-label {
  font-size: 0.6rem;
  font-weight: 700;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: var(--text-dim);
  margin-bottom: 5px;
}
.tutor .msg-label { color: var(--gold); }
.student .msg-label { color: var(--teal); text-align: right; }

.thinking-dots span {
  display: inline-block;
  width: 6px; height: 6px;
  border-radius: 50%;
  background: var(--text-dim);
  margin: 0 2px;
  animation: thinking 1.2s infinite;
}
.thinking-dots span:nth-child(2) { animation-delay: 0.2s; }
.thinking-dots span:nth-child(3) { animation-delay: 0.4s; }
@keyframes thinking { 0%,60%,100%{opacity:0.3;transform:scale(0.8)} 30%{opacity:1;transform:scale(1)} }

.socratic-input-area {
  border-top: 1px solid var(--border);
  padding: 14px 16px;
  display: flex;
  gap: 10px;
  align-items: flex-end;
  background: var(--panel);
  flex-shrink: 0;
}

.student-textarea {
  flex: 1;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 10px 14px;
  font-family: 'DM Sans', sans-serif;
  font-size: 0.88rem;
  color: var(--text);
  resize: none;
  outline: none;
  min-height: 44px;
  max-height: 140px;
  line-height: 1.5;
  transition: border-color var(--transition);
}
.student-textarea:focus { border-color: rgba(0,212,170,0.4); }
.student-textarea::placeholder { color: var(--text-dim); }

.btn-send {
  padding: 10px 18px;
  background: var(--teal-dim);
  border: 1px solid rgba(0,212,170,0.35);
  border-radius: 10px;
  color: var(--teal);
  font-family: 'DM Sans', sans-serif;
  font-size: 0.85rem;
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition);
  white-space: nowrap;
}
.btn-send:hover { background: rgba(0,212,170,0.2); }
.btn-send:disabled { opacity: 0.4; cursor: not-allowed; }

.socratic-hint {
  font-size: 0.7rem;
  color: var(--text-dim);
  padding: 8px 16px;
  text-align: center;
  border-top: 1px solid var(--border);
  background: var(--panel);
}

/* ══════════════════════════════════════════════════════════
   ACTIVITY 3: EVIDENCE TRIBUNAL
   ══════════════════════════════════════════════════════════ */

.tribunal-wrap {
  padding: 24px 20px;
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.tribunal-claim {
  background: linear-gradient(135deg, rgba(167,139,250,0.12), rgba(245,166,35,0.08));
  border: 1px solid rgba(167,139,250,0.3);
  border-radius: 14px;
  padding: 20px 24px;
  text-align: center;
}

.claim-label {
  font-size: 0.6rem;
  font-weight: 700;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  color: var(--violet);
  margin-bottom: 10px;
}

.claim-text {
  font-family: 'Fraunces', serif;
  font-size: 1.15rem;
  font-weight: 600;
  font-style: italic;
  color: var(--text);
  line-height: 1.5;
  max-width: 560px;
  margin: 0 auto;
}

.tribunal-arena {
  display: grid;
  grid-template-columns: 1fr 60px 1fr;
  gap: 12px;
  align-items: start;
}

.side-header {
  font-size: 0.65rem;
  font-weight: 700;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  padding: 6px 10px;
  border-radius: 6px;
  text-align: center;
  margin-bottom: 10px;
}
.side-header.for { background: var(--teal-dim); color: var(--teal); }
.side-header.against { background: var(--rose-dim); color: var(--rose); }

.argument-card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 14px 16px;
  margin-bottom: 10px;
  cursor: pointer;
  transition: all var(--transition);
  position: relative;
}
.argument-card:hover { border-color: var(--border-hi); }
.argument-card.selected-for {
  border-color: rgba(0,212,170,0.5);
  background: var(--teal-dim);
}
.argument-card.selected-against {
  border-color: rgba(251,113,133,0.5);
  background: var(--rose-dim);
}
.argument-card.weighted {
  border-style: dashed;
}

.arg-text { font-size: 0.83rem; line-height: 1.6; color: var(--text); margin-bottom: 8px; }
.arg-source { font-size: 0.68rem; color: var(--text-dim); font-style: italic; }

.arg-strength-bar {
  height: 3px;
  background: var(--border);
  border-radius: 2px;
  margin-top: 8px;
  overflow: hidden;
}
.arg-strength-fill {
  height: 100%;
  border-radius: 2px;
  transition: width 0.5s ease;
}
.for .arg-strength-fill { background: var(--teal); }
.against .arg-strength-fill { background: var(--rose); }

.tribunal-vs {
  display: flex;
  align-items: center;
  justify-content: center;
  padding-top: 32px;
}
.vs-circle {
  width: 44px;
  height: 44px;
  border-radius: 50%;
  background: var(--violet-dim);
  border: 1px solid rgba(167,139,250,0.3);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.72rem;
  font-weight: 700;
  color: var(--violet);
}

.verdict-zone {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 14px;
  padding: 20px;
}

.verdict-title {
  font-size: 0.72rem;
  font-weight: 700;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: var(--text-dim);
  margin-bottom: 14px;
}

.verdict-scale {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 16px;
}

.scale-label {
  font-size: 0.72rem;
  color: var(--text-dim);
  white-space: nowrap;
}
.scale-label.for { color: var(--teal); }
.scale-label.against { color: var(--rose); }

.verdict-slider {
  flex: 1;
  height: 6px;
  -webkit-appearance: none;
  appearance: none;
  background: linear-gradient(to right, var(--teal), var(--surface), var(--rose));
  border-radius: 3px;
  outline: none;
}
.verdict-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: var(--void);
  border: 2px solid var(--violet);
  box-shadow: 0 0 10px rgba(167,139,250,0.4);
  cursor: pointer;
}

.verdict-live-label {
  text-align: center;
  font-size: 0.8rem;
  font-weight: 700;
  letter-spacing: 0.04em;
  text-transform: uppercase;
  margin: 6px 0 14px;
  transition: color var(--transition);
  color: var(--text-dim);
}

.verdict-reasoning {
  width: 100%;
  min-height: 80px;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 10px 12px;
  font-family: 'DM Sans', sans-serif;
  font-size: 0.82rem;
  color: var(--text);
  resize: vertical;
  outline: none;
  transition: border-color var(--transition);
  margin-bottom: 12px;
}
.verdict-reasoning:focus { border-color: rgba(167,139,250,0.4); }
.verdict-reasoning::placeholder { color: var(--text-dim); }

.btn-deliver-verdict {
  width: 100%;
  padding: 11px 20px;
  background: linear-gradient(135deg, rgba(167,139,250,0.2), rgba(245,166,35,0.15));
  border: 1px solid rgba(167,139,250,0.4);
  border-radius: 9px;
  color: var(--violet);
  font-family: 'DM Sans', sans-serif;
  font-size: 0.88rem;
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition);
}
.btn-deliver-verdict:hover { background: rgba(167,139,250,0.25); }

.verdict-result {
  background: linear-gradient(135deg, rgba(167,139,250,0.15), rgba(245,166,35,0.1));
  border: 1px solid rgba(167,139,250,0.4);
  border-radius: 12px;
  padding: 20px;
  margin-top: 16px;
}
.verdict-result-title {
  font-family: 'Fraunces', serif;
  font-size: 1rem;
  font-weight: 600;
  color: var(--violet);
  margin-bottom: 10px;
}
.verdict-result-body {
  font-size: 0.85rem;
  line-height: 1.7;
  color: var(--text);
}

/* ══════════════════════════════════════════════════════════
   ACTIVITY 4: ANALOGY FORGE
   ══════════════════════════════════════════════════════════ */

.forge-wrap {
  padding: 24px 20px;
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.forge-concept-row {
  display: grid;
  grid-template-columns: 1fr auto 1fr;
  gap: 12px;
  align-items: center;
}

.forge-concept-box {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 16px 18px;
}
.forge-concept-box.source {
  border-color: rgba(56,189,248,0.3);
  background: var(--sky-dim);
}
.forge-concept-box.analogy {
  border-color: rgba(245,166,35,0.3);
  background: var(--gold-dim);
}

.forge-box-label {
  font-size: 0.58rem;
  font-weight: 700;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  color: var(--text-dim);
  margin-bottom: 6px;
}
.forge-concept-box.source .forge-box-label { color: var(--sky); }
.forge-concept-box.analogy .forge-box-label { color: var(--gold); }

.forge-concept-title {
  font-family: 'Fraunces', serif;
  font-size: 1rem;
  font-weight: 600;
  color: var(--text);
  margin-bottom: 6px;
}

.forge-concept-desc {
  font-size: 0.8rem;
  color: var(--text-dim);
  line-height: 1.55;
}

.forge-arrow {
  font-size: 1.5rem;
  color: var(--text-dim);
  text-align: center;
  flex-shrink: 0;
}

.forge-mappings {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 12px;
  overflow: hidden;
}

.forge-mapping-row {
  display: grid;
  grid-template-columns: 1fr auto 1fr;
  gap: 0;
  border-bottom: 1px solid var(--border);
  align-items: stretch;
}
.forge-mapping-row:last-child { border-bottom: none; }

.forge-mapping-cell {
  padding: 12px 16px;
  font-size: 0.83rem;
  line-height: 1.5;
  color: var(--text);
}
.forge-mapping-cell:first-child {
  border-right: 1px solid var(--border);
  color: var(--sky);
  font-weight: 500;
}
.forge-mapping-cell:last-child {
  color: var(--gold);
  font-weight: 500;
}

.forge-mapping-connector {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0 12px;
  font-size: 0.75rem;
  color: var(--text-dim);
  border-right: 1px solid var(--border);
}

.forge-tasks {
  display: flex;
  flex-direction: column;
  gap: 14px;
}

.forge-task {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 16px 18px;
}

.forge-task-label {
  font-size: 0.65rem;
  font-weight: 700;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: var(--text-dim);
  margin-bottom: 6px;
}
.forge-task.extend .forge-task-label { color: var(--teal); }
.forge-task.break-it .forge-task-label { color: var(--rose); }
.forge-task.rebuild .forge-task-label { color: var(--violet); }

.forge-task-prompt {
  font-size: 0.85rem;
  color: var(--text);
  line-height: 1.6;
  margin-bottom: 10px;
}

.forge-response {
  width: 100%;
  min-height: 72px;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 10px 12px;
  font-family: 'DM Sans', sans-serif;
  font-size: 0.83rem;
  color: var(--text);
  resize: vertical;
  outline: none;
  transition: border-color var(--transition);
}
.forge-task.extend .forge-response:focus { border-color: rgba(0,212,170,0.4); }
.forge-task.break-it .forge-response:focus { border-color: rgba(251,113,133,0.4); }
.forge-task.rebuild .forge-response:focus { border-color: rgba(167,139,250,0.4); }

.btn-forge-check {
  margin-top: 10px;
  padding: 8px 18px;
  background: var(--surface-hi);
  border: 1px solid var(--border-hi);
  border-radius: 7px;
  color: var(--text-dim);
  font-family: 'DM Sans', sans-serif;
  font-size: 0.78rem;
  font-weight: 500;
  cursor: pointer;
  transition: all var(--transition);
}
.btn-forge-check:hover { color: var(--text); border-color: rgba(255,255,255,0.2); }

.forge-feedback {
  margin-top: 10px;
  padding: 10px 14px;
  border-radius: 8px;
  font-size: 0.82rem;
  line-height: 1.6;
  border: 1px solid var(--border);
  background: var(--panel);
  color: var(--text);
  animation: fadeSlideIn 0.3s ease;
}

/* ══════════════════════════════════════════════════════════
   ACTIVITY 5: CONCEPT TIMELINE
   ══════════════════════════════════════════════════════════ */

.timeline-wrap {
  padding: 24px 20px;
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.timeline-intro {
  font-size: 0.85rem;
  color: var(--text-dim);
  line-height: 1.6;
  padding: 14px 18px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 10px;
}

.timeline-track {
  position: relative;
  padding: 10px 0;
}

.timeline-axis {
  position: absolute;
  left: 50%;
  top: 0;
  bottom: 0;
  width: 2px;
  background: linear-gradient(to bottom, var(--void), var(--border), var(--void));
  transform: translateX(-50%);
}

.timeline-items {
  display: flex;
  flex-direction: column;
  gap: 24px;
  position: relative;
}

.timeline-item {
  display: grid;
  grid-template-columns: 1fr 60px 1fr;
  gap: 12px;
  align-items: start;
  animation: fadeSlideIn 0.4s ease both;
}
.timeline-item:nth-child(even) .timeline-card { order: 3; }
.timeline-item:nth-child(even) .timeline-spacer { order: 2; }
.timeline-item:nth-child(even) .timeline-card-empty { order: 1; }

.timeline-card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 16px 18px;
  transition: all var(--transition);
  cursor: pointer;
}
.timeline-card:hover { border-color: var(--border-hi); background: var(--surface-hi); }
.timeline-card.revealed {
  border-color: rgba(56,189,248,0.4);
  background: var(--sky-dim);
}

.timeline-card-empty {
  /* placeholder for alternating layout */
}

.timeline-node {
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  gap: 4px;
}

.timeline-dot {
  width: 14px;
  height: 14px;
  border-radius: 50%;
  background: var(--sky);
  border: 2px solid var(--void);
  box-shadow: 0 0 12px rgba(56,189,248,0.4);
  z-index: 2;
  position: relative;
}

.timeline-era {
  font-size: 0.6rem;
  font-weight: 700;
  color: var(--sky);
  text-align: center;
  letter-spacing: 0.06em;
  white-space: nowrap;
}

.card-concept {
  font-family: 'Fraunces', serif;
  font-size: 0.95rem;
  font-weight: 600;
  color: var(--text);
  margin-bottom: 4px;
}

.card-detail {
  font-size: 0.78rem;
  color: var(--text-dim);
  line-height: 1.5;
}

.card-hidden-prompt {
  font-size: 0.75rem;
  color: var(--sky);
  font-style: italic;
  opacity: 0.7;
}

.timeline-question-box {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 18px 20px;
  margin-top: 10px;
}

.tq-label {
  font-size: 0.65rem;
  font-weight: 700;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  color: var(--sky);
  margin-bottom: 8px;
}

.tq-prompt {
  font-size: 0.88rem;
  color: var(--text);
  line-height: 1.6;
  margin-bottom: 12px;
}

.tq-input {
  width: 100%;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 10px 12px;
  font-family: 'DM Sans', sans-serif;
  font-size: 0.83rem;
  color: var(--text);
  resize: none;
  outline: none;
  min-height: 70px;
  transition: border-color var(--transition);
  margin-bottom: 10px;
}
.tq-input:focus { border-color: rgba(56,189,248,0.4); }

.btn-reveal {
  padding: 8px 18px;
  background: var(--sky-dim);
  border: 1px solid rgba(56,189,248,0.35);
  border-radius: 7px;
  color: var(--sky);
  font-family: 'DM Sans', sans-serif;
  font-size: 0.78rem;
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition);
}
.btn-reveal:hover { background: rgba(56,189,248,0.2); }

/* ══════════════════════════════════════════════════════════
   ASSUMPTION EXCAVATOR
   ══════════════════════════════════════════════════════════ */

.assume-wrap { display: flex; flex-direction: column; gap: 18px; }

.assume-intro {
  font-size: 0.82rem; color: var(--text-dim); line-height: 1.6;
  padding: 10px 14px; background: var(--surface);
  border-radius: 8px; border: 1px solid var(--border);
}

.assume-card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 16px 18px;
  display: flex; flex-direction: column; gap: 10px;
  transition: border-color var(--transition);
}
.assume-card:focus-within { border-color: var(--violet); }

.assume-card-head {
  display: flex; align-items: flex-start; gap: 12px;
}
.assume-num {
  font-family: 'Fraunces', serif;
  font-size: 1.1rem; font-weight: 600;
  color: var(--violet); flex-shrink: 0; line-height: 1.2;
}
.assume-text {
  font-size: 0.88rem; color: var(--text); line-height: 1.55; flex: 1;
}
.assume-type-badge {
  font-size: 0.58rem; font-weight: 700; letter-spacing: 0.08em;
  text-transform: uppercase; padding: 2px 8px; border-radius: 20px;
  background: var(--violet-dim); border: 1px solid rgba(167,139,250,0.3);
  color: var(--violet); white-space: nowrap; flex-shrink: 0; align-self: flex-start;
}

.assume-rating {
  display: flex; align-items: center; gap: 10px; flex-wrap: wrap;
}
.assume-rating-label {
  font-size: 0.65rem; font-weight: 700; letter-spacing: 0.08em;
  text-transform: uppercase; color: var(--text-dim);
}
.assume-stars { display: flex; gap: 4px; }
.assume-star {
  width: 28px; height: 28px; border-radius: 6px;
  border: 1px solid var(--border-hi); background: var(--panel);
  cursor: pointer; font-size: 0.8rem;
  display: flex; align-items: center; justify-content: center;
  transition: all var(--transition);
}
.assume-star:hover, .assume-star.selected { background: var(--violet-dim); border-color: var(--violet); }
.assume-star.selected { color: var(--violet); }

.assume-response-area { display: none; flex-direction: column; gap: 8px; }
.assume-response-area.show { display: flex; }
.assume-response-prompt {
  font-size: 0.8rem; color: var(--text-dim); line-height: 1.5;
  padding: 8px 12px; background: var(--panel);
  border-radius: 6px; border-left: 2px solid var(--violet);
}
.assume-textarea {
  width: 100%; background: var(--panel); border: 1px solid var(--border);
  border-radius: 8px; padding: 10px 12px;
  font-family: 'DM Sans', sans-serif; font-size: 0.83rem;
  color: var(--text); resize: none; outline: none;
  transition: border-color var(--transition);
  min-height: 64px;
}
.assume-textarea:focus { border-color: rgba(167,139,250,0.4); }
.btn-assume-check {
  align-self: flex-start;
  padding: 7px 16px; background: var(--surface-hi);
  border: 1px solid var(--border-hi); border-radius: 7px;
  color: var(--text-dim); font-family: 'DM Sans', sans-serif;
  font-size: 0.77rem; font-weight: 500; cursor: pointer;
  transition: all var(--transition);
}
.btn-assume-check:hover { color: var(--violet); border-color: rgba(167,139,250,0.4); }
.assume-feedback {
  margin-top: 4px; padding: 10px 14px; border-radius: 8px;
  font-size: 0.82rem; line-height: 1.6;
  border: 1px solid rgba(167,139,250,0.2);
  background: var(--panel); color: var(--text);
  animation: fadeSlideIn 0.3s ease;
}

/* ══════════════════════════════════════════════════════════
   TRANSFER CHALLENGE
   ══════════════════════════════════════════════════════════ */

.transfer-wrap { display: flex; flex-direction: column; gap: 20px; }

.transfer-concept-box {
  background: var(--surface); border: 1px solid var(--border);
  border-radius: 12px; padding: 16px 18px;
}
.transfer-concept-label {
  font-size: 0.62rem; font-weight: 700; letter-spacing: 0.1em;
  text-transform: uppercase; color: var(--teal); margin-bottom: 6px;
}
.transfer-concept-name {
  font-family: 'Fraunces', serif; font-size: 1.05rem;
  font-weight: 600; color: var(--text); margin-bottom: 6px;
}
.transfer-concept-desc {
  font-size: 0.83rem; color: var(--text-dim); line-height: 1.55;
}

.transfer-scenarios-label {
  font-size: 0.65rem; font-weight: 700; letter-spacing: 0.1em;
  text-transform: uppercase; color: var(--text-dim);
}

.transfer-scenarios { display: flex; flex-direction: column; gap: 10px; }

.transfer-scenario {
  background: var(--surface); border: 1px solid var(--border);
  border-radius: 10px; padding: 14px 16px;
  cursor: pointer; transition: all var(--transition);
  display: flex; gap: 14px; align-items: flex-start;
}
.transfer-scenario:hover { border-color: var(--teal); background: var(--surface-hi); }
.transfer-scenario.selected {
  border-color: var(--teal); background: var(--teal-dim);
  box-shadow: 0 0 16px rgba(0,212,170,0.15);
}
.transfer-scenario-icon {
  font-size: 1.4rem; line-height: 1; flex-shrink: 0; margin-top: 2px;
}
.transfer-scenario-body { flex: 1; }
.transfer-scenario-domain {
  font-size: 0.62rem; font-weight: 700; letter-spacing: 0.08em;
  text-transform: uppercase; color: var(--teal); margin-bottom: 4px;
}
.transfer-scenario-situation {
  font-size: 0.85rem; color: var(--text); line-height: 1.5; margin-bottom: 4px;
}
.transfer-scenario-question {
  font-size: 0.78rem; color: var(--text-dim); font-style: italic; line-height: 1.4;
}

.transfer-work-area {
  background: var(--surface); border: 1px solid var(--border);
  border-radius: 12px; padding: 16px 18px;
  display: flex; flex-direction: column; gap: 12px;
}
.transfer-work-title {
  font-size: 0.65rem; font-weight: 700; letter-spacing: 0.1em;
  text-transform: uppercase; color: var(--teal);
}
.transfer-task { display: flex; flex-direction: column; gap: 6px; }
.transfer-task-prompt {
  font-size: 0.85rem; color: var(--text); line-height: 1.55;
}
.transfer-textarea {
  width: 100%; background: var(--panel); border: 1px solid var(--border);
  border-radius: 8px; padding: 10px 12px;
  font-family: 'DM Sans', sans-serif; font-size: 0.83rem;
  color: var(--text); resize: none; outline: none;
  transition: border-color var(--transition); min-height: 64px;
}
.transfer-textarea:focus { border-color: rgba(0,212,170,0.4); }
.btn-transfer-check {
  align-self: flex-start;
  padding: 7px 16px; background: var(--teal-dim);
  border: 1px solid rgba(0,212,170,0.35); border-radius: 7px;
  color: var(--teal); font-family: 'DM Sans', sans-serif;
  font-size: 0.77rem; font-weight: 600; cursor: pointer;
  transition: all var(--transition);
}
.btn-transfer-check:hover { background: rgba(0,212,170,0.2); }
.transfer-feedback {
  padding: 10px 14px; border-radius: 8px; font-size: 0.82rem;
  line-height: 1.6; border: 1px solid rgba(0,212,170,0.2);
  background: var(--panel); color: var(--text);
  animation: fadeSlideIn 0.3s ease;
}

/* ══════════════════════════════════════════════════════════
   QUESTION GENERATOR
   ══════════════════════════════════════════════════════════ */

.qgen-wrap { display: flex; flex-direction: column; gap: 18px; }

.qgen-intro {
  font-size: 0.82rem; color: var(--text-dim); line-height: 1.6;
  padding: 10px 14px; background: var(--surface);
  border-radius: 8px; border: 1px solid var(--border);
}

.qgen-category { display: flex; flex-direction: column; gap: 8px; }
.qgen-category-label {
  display: flex; align-items: center; gap: 8px;
  font-size: 0.63rem; font-weight: 700; letter-spacing: 0.1em;
  text-transform: uppercase;
}
.qgen-category-dot {
  width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0;
}

.qgen-question {
  background: var(--surface); border: 1px solid var(--border);
  border-radius: 8px; padding: 11px 14px;
  display: flex; align-items: flex-start; gap: 10px;
  cursor: pointer; transition: all var(--transition);
  user-select: none;
}
.qgen-question:hover { border-color: var(--border-hi); background: var(--surface-hi); }
.qgen-question.starred {
  border-color: var(--gold); background: var(--gold-dim);
}
.qgen-question-text {
  font-size: 0.85rem; color: var(--text); line-height: 1.5; flex: 1;
}
.qgen-star-btn {
  font-size: 1rem; background: none; border: none; cursor: pointer;
  color: var(--text-dim); transition: color var(--transition);
  flex-shrink: 0; padding: 0; line-height: 1;
}
.qgen-question.starred .qgen-star-btn { color: var(--gold); }

.qgen-add-section {
  background: var(--surface); border: 1px solid var(--border);
  border-radius: 12px; padding: 14px 16px;
  display: flex; flex-direction: column; gap: 8px;
}
.qgen-add-label {
  font-size: 0.65rem; font-weight: 700; letter-spacing: 0.1em;
  text-transform: uppercase; color: var(--gold);
}
.qgen-add-prompt {
  font-size: 0.82rem; color: var(--text-dim); line-height: 1.5;
}
.qgen-add-textarea {
  width: 100%; background: var(--panel); border: 1px solid var(--border);
  border-radius: 8px; padding: 10px 12px;
  font-family: 'DM Sans', sans-serif; font-size: 0.83rem;
  color: var(--text); resize: none; outline: none;
  transition: border-color var(--transition); min-height: 60px;
}
.qgen-add-textarea:focus { border-color: rgba(245,166,35,0.4); }
.btn-qgen-add {
  align-self: flex-start;
  padding: 7px 14px; background: var(--gold-dim);
  border: 1px solid rgba(245,166,35,0.3); border-radius: 7px;
  color: var(--gold); font-family: 'DM Sans', sans-serif;
  font-size: 0.77rem; font-weight: 600; cursor: pointer;
  transition: all var(--transition);
}
.btn-qgen-add:hover { background: rgba(245,166,35,0.2); }

.qgen-rationale-section {
  background: var(--surface); border: 1px solid var(--border);
  border-radius: 12px; padding: 14px 16px;
  display: flex; flex-direction: column; gap: 8px;
}
.qgen-rationale-label {
  font-size: 0.65rem; font-weight: 700; letter-spacing: 0.1em;
  text-transform: uppercase; color: var(--gold);
}
.qgen-rationale-prompt { font-size: 0.85rem; color: var(--text); line-height: 1.5; }
.qgen-rationale-textarea {
  width: 100%; background: var(--panel); border: 1px solid var(--border);
  border-radius: 8px; padding: 10px 12px;
  font-family: 'DM Sans', sans-serif; font-size: 0.83rem;
  color: var(--text); resize: none; outline: none;
  transition: border-color var(--transition); min-height: 64px;
}
.qgen-rationale-textarea:focus { border-color: rgba(245,166,35,0.4); }
.btn-qgen-submit {
  align-self: flex-start;
  padding: 8px 18px; background: var(--gold-dim);
  border: 1px solid rgba(245,166,35,0.4); border-radius: 7px;
  color: var(--gold); font-family: 'DM Sans', sans-serif;
  font-size: 0.78rem; font-weight: 600; cursor: pointer;
  transition: all var(--transition);
}
.btn-qgen-submit:hover { background: rgba(245,166,35,0.22); }
.qgen-feedback {
  padding: 10px 14px; border-radius: 8px; font-size: 0.82rem;
  line-height: 1.6; border: 1px solid rgba(245,166,35,0.2);
  background: var(--panel); color: var(--text);
  animation: fadeSlideIn 0.3s ease;
}

/* ══════════════════════════════════════════════════════════
   BOOK BROWSER (left panel)
   ══════════════════════════════════════════════════════════ */

/* Loading state */
.books-loading {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 14px 0;
  color: var(--text-dim);
  font-size: 0.78rem;
}

.books-spinner {
  width: 14px;
  height: 14px;
  border: 2px solid var(--border-hi);
  border-top-color: var(--teal);
  border-radius: 50%;
  animation: spin 0.7s linear infinite;
  flex-shrink: 0;
}

.books-error {
  padding: 10px 0;
  font-size: 0.78rem;
  color: var(--rose);
}

.books-retry-btn {
  background: none;
  border: none;
  color: var(--teal);
  font-size: 0.78rem;
  cursor: pointer;
  text-decoration: underline;
  padding: 0;
  font-family: inherit;
}

/* Search input */
.book-search {
  width: 100%;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 7px;
  padding: 8px 10px 8px 32px;
  font-family: 'DM Sans', sans-serif;
  font-size: 0.8rem;
  color: var(--text);
  outline: none;
  transition: border-color var(--transition);
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='14' height='14' viewBox='0 0 24 24' fill='none' stroke='%238888aa' stroke-width='2'%3E%3Ccircle cx='11' cy='11' r='8'/%3E%3Cpath d='m21 21-4.35-4.35'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: 10px center;
  margin-bottom: 8px;
}
.book-search:focus { border-color: rgba(245,166,35,0.4); }
.book-search::placeholder { color: var(--text-dim); }

.book-count {
  font-size: 0.62rem;
  color: var(--text-dim);
  letter-spacing: 0.05em;
  text-transform: uppercase;
  margin-bottom: 8px;
}

/* Book list */
.book-list {
  display: flex;
  flex-direction: column;
  gap: 5px;
  max-height: 340px;
  overflow-y: auto;
}

.book-item {
  padding: 10px 12px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 8px;
  cursor: pointer;
  transition: all var(--transition);
  text-align: left;
  width: 100%;
  font-family: 'DM Sans', sans-serif;
}
.book-item:hover {
  border-color: rgba(245,166,35,0.35);
  background: var(--surface-hi);
}

.book-item-title {
  font-size: 0.8rem;
  font-weight: 600;
  color: var(--text);
  line-height: 1.35;
  margin-bottom: 4px;
}

.book-item-meta {
  display: flex;
  align-items: center;
  gap: 6px;
  flex-wrap: wrap;
}

.book-subject-badge {
  font-size: 0.58rem;
  font-weight: 700;
  letter-spacing: 0.07em;
  text-transform: uppercase;
  padding: 2px 7px;
  border-radius: 10px;
  background: var(--gold-dim);
  color: var(--gold);
  border: 1px solid rgba(245,166,35,0.2);
}

.book-item-author {
  font-size: 0.68rem;
  color: var(--text-dim);
}

/* Focus view */
.book-back-btn {
  background: none;
  border: none;
  color: var(--teal);
  font-size: 0.72rem;
  font-family: 'DM Sans', sans-serif;
  font-weight: 600;
  cursor: pointer;
  padding: 0;
  margin-bottom: 10px;
  display: flex;
  align-items: center;
  gap: 4px;
  transition: color var(--transition);
}
.book-back-btn:hover { color: var(--text); }

.selected-book-card {
  background: linear-gradient(135deg, rgba(245,166,35,0.08), rgba(0,212,170,0.05));
  border: 1px solid rgba(245,166,35,0.25);
  border-radius: 10px;
  padding: 12px 14px;
  margin-bottom: 14px;
}

.selected-book-title {
  font-family: 'Fraunces', serif;
  font-size: 0.9rem;
  font-weight: 600;
  color: var(--text);
  line-height: 1.35;
  margin-bottom: 4px;
}

.selected-book-subject {
  font-size: 0.62rem;
  font-weight: 700;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: var(--gold);
}

/* TOC loading */
.toc-loading {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 0;
  color: var(--text-dim);
  font-size: 0.78rem;
}

/* TOC selects */
.toc-select {
  width: 100%;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 7px;
  padding: 8px 10px;
  font-family: 'DM Sans', sans-serif;
  font-size: 0.8rem;
  color: var(--text);
  outline: none;
  transition: border-color var(--transition);
  -webkit-appearance: none;
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%238888aa' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 10px center;
  padding-right: 28px;
}
.toc-select:focus { border-color: rgba(245,166,35,0.4); }
.toc-select:disabled { opacity: 0.4; cursor: not-allowed; }
.toc-select option { background: var(--panel); color: var(--text); }

/* Chapter metadata */
.chapter-meta {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 8px;
  flex-wrap: wrap;
}

.chapter-wc-pill {
  font-size: 0.65rem;
  font-weight: 600;
  padding: 3px 9px;
  border-radius: 10px;
  background: var(--teal-dim);
  color: var(--teal);
  border: 1px solid rgba(0,212,170,0.25);
}

.chapter-link {
  font-size: 0.65rem;
  color: var(--text-dim);
  text-decoration: none;
  transition: color var(--transition);
}
.chapter-link:hover { color: var(--teal); }

/* Load / Add chapter button */
.btn-load-chapter {
  width: 100%;
  margin-top: 12px;
  padding: 9px 14px;
  background: var(--teal-dim);
  border: 1px solid rgba(0,212,170,0.35);
  border-radius: 8px;
  color: var(--teal);
  font-family: 'DM Sans', sans-serif;
  font-size: 0.8rem;
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition);
}
.btn-load-chapter:hover { background: rgba(0,212,170,0.22); }
.btn-load-chapter:disabled { opacity: 0.4; cursor: not-allowed; }

/* ── Source tray (multi-source chips) ── */
.source-tray {
  display: flex; flex-wrap: wrap; gap: 6px;
  margin-top: 10px; margin-bottom: 2px;
}
.source-chip {
  display: flex; align-items: center; gap: 5px;
  background: rgba(0,212,170,0.1);
  border: 1px solid rgba(0,212,170,0.3);
  border-radius: 20px;
  padding: 4px 8px 4px 10px;
  font-size: 0.73rem; color: var(--teal);
  font-family: 'DM Sans', sans-serif;
  max-width: 100%; animation: chipIn 0.15s ease;
}
@keyframes chipIn { from { opacity:0; transform:scale(0.85); } to { opacity:1; transform:scale(1); } }
.source-chip-icon { font-size: 0.85em; }
.source-chip-body { display:flex; flex-direction:column; gap:1px; min-width:0; }
.source-chip-label { font-weight:600; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:160px; }
.source-chip-meta { color: var(--text-dim); font-size:0.68rem; white-space:nowrap; }
.source-chip-remove {
  margin-left: 2px; padding: 0 2px;
  background: none; border: none; cursor: pointer;
  color: rgba(0,212,170,0.5); font-size: 1rem; line-height:1;
  transition: color 0.15s;
}
.source-chip-remove:hover { color: var(--rose); }

/* ── URL fetch row ── */
.url-fetch-row {
  display: flex; gap: 6px; margin-top: 10px; align-items: center;
}
.url-fetch-input {
  flex: 1; padding: 7px 10px;
  background: var(--surface); border: 1px solid var(--border-hi);
  border-radius: 7px; color: var(--text);
  font-family: 'DM Mono', monospace; font-size: 0.72rem;
  outline: none; transition: border-color 0.18s;
}
.url-fetch-input:focus { border-color: rgba(0,212,170,0.5); }
.url-fetch-input::placeholder { color: var(--text-dim); }
.btn-fetch-url {
  padding: 7px 11px; white-space: nowrap;
  background: var(--teal-dim); border: 1px solid rgba(0,212,170,0.35);
  border-radius: 7px; color: var(--teal);
  font-family: 'DM Sans', sans-serif; font-size: 0.75rem; font-weight: 600;
  cursor: pointer; transition: all 0.18s;
}
.btn-fetch-url:hover { background: rgba(0,212,170,0.2); }
.btn-fetch-url:disabled { opacity: 0.45; cursor: not-allowed; }
.url-fetch-status {
  font-size: 0.7rem; color: var(--text-dim);
  margin-top: 4px; min-height: 1em;
}
.url-fetch-status.error { color: var(--rose); }
.url-fetch-status.success { color: var(--teal); }

/* ── File upload button ── */
.file-upload-btn {
  width: 100%; margin-top: 8px; padding: 8px 14px;
  background: rgba(167,139,250,0.08);
  border: 1px dashed rgba(167,139,250,0.35);
  border-radius: 8px; color: var(--violet);
  font-family: 'DM Sans', sans-serif; font-size: 0.78rem; font-weight: 600;
  cursor: pointer; transition: all 0.18s; text-align: center;
}
.file-upload-btn:hover { background: rgba(167,139,250,0.15); border-style: solid; }
.file-upload-status {
  font-size: 0.7rem; color: var(--text-dim);
  margin-top: 4px; min-height: 1em;
}
.file-upload-status.error { color: var(--rose); }
.file-upload-status.success { color: var(--teal); }
#file-upload-input { display: none; }

/* ── Source section label / separator ── */
.oer-source-sep {
  font-size: 0.65rem; font-weight: 700; letter-spacing: 0.07em;
  text-transform: uppercase; color: var(--text-dim);
  margin-top: 12px; margin-bottom: 2px; padding-bottom: 4px;
  border-bottom: 1px solid var(--border);
}

/* Chapter load notice */
.chapter-notice {
  margin-top: 10px;
  padding: 9px 12px;
  border-radius: 8px;
  font-size: 0.78rem;
  line-height: 1.5;
}
.chapter-notice.success {
  background: var(--teal-dim);
  border: 1px solid rgba(0,212,170,0.3);
  color: var(--teal);
}
.chapter-notice.error {
  background: var(--rose-dim);
  border: 1px solid rgba(251,113,133,0.3);
  color: var(--rose);
}

/* Paste toggle */
.paste-toggle-btn {
  background: none;
  border: none;
  color: var(--text-dim);
  font-size: 0.7rem;
  font-family: 'DM Sans', sans-serif;
  font-weight: 500;
  cursor: pointer;
  padding: 0;
  margin-bottom: 0;
  transition: color var(--transition);
  letter-spacing: 0.02em;
}
.paste-toggle-btn:hover { color: var(--text); }
.paste-toggle-btn.active { color: var(--gold); }

/* ── UTILITIES ── */
.hidden { display: none !important; }

button { cursor: pointer; }

.activity-content {
  animation: fadeIn 0.4s ease;
}
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

/* Tooltip */
#node-tooltip {
  position: fixed;
  background: var(--panel);
  border: 1px solid var(--border-hi);
  border-radius: 10px;
  padding: 10px 14px;
  font-size: 0.78rem;
  color: var(--text);
  max-width: 260px;
  line-height: 1.5;
  pointer-events: none;
  z-index: 999;
  box-shadow: 0 8px 30px rgba(0,0,0,0.6);
  display: none;
}
#node-tooltip .tt-title { font-weight: 700; color: var(--gold); margin-bottom: 3px; font-size: 0.82rem; }
#node-tooltip .tt-body { color: var(--text-dim); }

/* ══════════════════════════════════════════════════════════
   SHARE FEATURE
   ══════════════════════════════════════════════════════════ */

.btn-share {
  flex-shrink: 0;
  padding: 0 14px;
  background: var(--surface);
  border: 1px solid var(--border-hi);
  border-radius: 9px;
  color: var(--text-dim);
  font-family: 'DM Sans', sans-serif;
  font-size: 0.78rem;
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition);
  display: flex;
  align-items: center;
  gap: 5px;
  white-space: nowrap;
}
.btn-share:hover {
  background: var(--surface-hi);
  color: var(--teal);
  border-color: rgba(0,212,170,0.4);
}
.btn-share.share-copied {
  color: var(--teal);
  border-color: rgba(0,212,170,0.5);
  background: var(--teal-dim);
}
.btn-share.hidden { display: none; }

.shared-banner {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  padding: 10px 18px;
  background: linear-gradient(135deg, rgba(0,212,170,0.07), rgba(56,189,248,0.05));
  border-bottom: 1px solid rgba(0,212,170,0.18);
  flex-shrink: 0;
  flex-wrap: wrap;
}

.shared-banner-left {
  display: flex;
  align-items: center;
  gap: 10px;
}

.shared-banner-icon {
  font-size: 1.15rem;
  line-height: 1;
}

.shared-banner-text {
  display: flex;
  flex-direction: column;
  gap: 1px;
}

.shared-banner-label {
  font-size: 0.58rem;
  font-weight: 700;
  letter-spacing: 0.11em;
  text-transform: uppercase;
  color: var(--teal);
}

.shared-banner-title {
  font-size: 0.82rem;
  color: var(--text);
  font-weight: 500;
}

.btn-generate-own {
  flex-shrink: 0;
  padding: 5px 14px;
  background: var(--surface);
  border: 1px solid var(--border-hi);
  border-radius: 20px;
  color: var(--text-dim);
  font-family: 'DM Sans', sans-serif;
  font-size: 0.72rem;
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition);
  white-space: nowrap;
}
.btn-generate-own:hover {
  color: var(--gold);
  border-color: rgba(245,166,35,0.4);
  background: var(--gold-dim);
}

/* ── SAVE SESSION ── */
.btn-save {
  flex-shrink: 0;
  padding: 0 14px;
  background: var(--surface);
  border: 1px solid var(--border-hi);
  border-radius: 9px;
  color: var(--text-dim);
  font-family: 'DM Sans', sans-serif;
  font-size: 0.78rem;
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition);
  display: flex;
  align-items: center;
  gap: 5px;
  white-space: nowrap;
}
.btn-save:hover {
  background: var(--surface-hi);
  color: var(--violet);
  border-color: rgba(167,139,250,0.4);
}
.btn-save.save-done {
  color: var(--violet);
  border-color: rgba(167,139,250,0.5);
  background: var(--violet-dim);
}
.btn-save.hidden { display: none; }

/* ── SUITE NAV ── */
.suite-nav {
  background: rgba(9,9,15,0.7);
  border-bottom: 1px solid var(--border);
  padding: 0 24px;
  height: 34px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  position: sticky;
  top: 56px; /* sits below the 56px topbar */
  z-index: 199;
  backdrop-filter: blur(8px);
  flex-shrink: 0;
}
.suite-nav-home {
  font-size: 0.63rem;
  font-weight: 600;
  letter-spacing: 0.07em;
  text-transform: uppercase;
  color: var(--text-dim);
  text-decoration: none;
  transition: color 0.18s;
  flex-shrink: 0;
}
.suite-nav-home:hover { color: var(--text); }
.suite-nav-tools { display: flex; align-items: center; gap: 4px; }
.suite-nav-pill {
  display: inline-flex;
  align-items: center;
  gap: 5px;
  padding: 3px 10px;
  border-radius: 20px;
  font-size: 0.63rem;
  font-weight: 600;
  letter-spacing: 0.05em;
  text-transform: uppercase;
  text-decoration: none;
  border: 1px solid transparent;
  transition: all 0.18s;
  white-space: nowrap;
}
/* inactive pills — solid legible text (≥4.5:1 on void #09090f) */
.suite-nav-pill.pill-companion { color: #f5c06a; border-color: rgba(245,192,106,0.45); }
.suite-nav-pill.pill-companion:hover { background: rgba(245,192,106,0.12); border-color: rgba(245,192,106,0.65); color: #fdd28a; }
.suite-nav-pill.pill-builder   { color: #c8d8ec; border-color: rgba(200,216,236,0.35); }
.suite-nav-pill.pill-builder:hover   { background: rgba(200,216,236,0.1); border-color: rgba(200,216,236,0.55); color: #e8eef8; }
.suite-nav-pill.pill-nova      { color: #f5c06a; border-color: rgba(245,192,106,0.45); }
.suite-nav-pill.pill-nova:hover      { background: rgba(245,192,106,0.12); border-color: rgba(245,192,106,0.65); color: #fdd28a; }
.suite-nav-pill.pill-rhizo     { color: #6de8c8; border-color: rgba(109,232,200,0.4); }
.suite-nav-pill.pill-rhizo:hover     { background: rgba(109,232,200,0.1); border-color: rgba(109,232,200,0.6); color: #90f0d8; }
.suite-nav-pill.pill-sylva     { color: #a8e6c8; border-color: rgba(168,230,200,0.35); }
.suite-nav-pill.pill-sylva:hover     { background: rgba(168,230,200,0.1); border-color: rgba(168,230,200,0.55); color: #c0f0d8; }
.suite-nav-pill.pill-sylva.pill-active { background: rgba(168,230,200,0.12); border-color: rgba(168,230,200,0.45); color: #a8e6c8; font-weight: 700; }
.suite-nav-pill.pill-active { cursor: default; pointer-events: none; }
.suite-nav-pill.pill-nova.pill-active { background: rgba(245,192,106,0.15); border-color: rgba(245,192,106,0.55); color: #fdd28a; font-weight: 700; }

/* ══════════════════════════════════════════════════════════
   RESPONSIVE — TABLET & MOBILE
   ══════════════════════════════════════════════════════════ */

@media (max-width: 1024px) {
  .context-panel { width: 240px; }
  .suite-nav-pill { padding: 3px 8px; font-size: 0.65rem; }
  .activity-ribbon { gap: 6px; padding: 0 14px; }
  .activity-tile { padding: 8px 10px; }
}

@media (max-width: 768px) {
  /* Suite nav — hide tool links */
  .suite-nav-tools { display: none; }
}

/* ── Light theme suite-nav background ── */
[data-theme="light"] .suite-nav {
  background: rgba(240,240,248,0.92);
}

/* ── Light theme: suite-nav home & pills need dark colours on light bg ── */
[data-theme="light"] .suite-nav-home { color: #505070; }
[data-theme="light"] .suite-nav-home:hover { color: #12121e; }
[data-theme="light"] .suite-nav-pill.pill-companion { color: #7a5800; border-color: rgba(122,88,0,0.35); }
[data-theme="light"] .suite-nav-pill.pill-companion:hover { background: rgba(122,88,0,0.08); border-color: rgba(122,88,0,0.55); color: #5a4000; }
[data-theme="light"] .suite-nav-pill.pill-builder   { color: #003865; border-color: rgba(0,56,101,0.35); }
[data-theme="light"] .suite-nav-pill.pill-builder:hover   { background: rgba(0,56,101,0.08); border-color: rgba(0,56,101,0.55); color: #002244; }
[data-theme="light"] .suite-nav-pill.pill-nova      { color: #7a5800; border-color: rgba(122,88,0,0.35); }
[data-theme="light"] .suite-nav-pill.pill-nova:hover      { background: rgba(122,88,0,0.08); border-color: rgba(122,88,0,0.55); color: #5a4000; }
[data-theme="light"] .suite-nav-pill.pill-nova.pill-active { background: rgba(122,88,0,0.10); border-color: rgba(122,88,0,0.45); color: #7a5800; }
[data-theme="light"] .suite-nav-pill.pill-rhizo     { color: #006a50; border-color: rgba(0,106,80,0.35); }
[data-theme="light"] .suite-nav-pill.pill-rhizo:hover     { background: rgba(0,106,80,0.08); border-color: rgba(0,106,80,0.55); color: #004a38; }
[data-theme="light"] .suite-nav-pill.pill-sylva     { color: #1a5c3a; border-color: rgba(26,92,58,0.35); }
[data-theme="light"] .suite-nav-pill.pill-sylva:hover     { background: rgba(26,92,58,0.08); border-color: rgba(26,92,58,0.55); color: #0f3d26; }
[data-theme="light"] .suite-nav-pill.pill-sylva.pill-active { background: rgba(26,92,58,0.10); border-color: rgba(26,92,58,0.45); color: #1a5c3a; }

/* ── Light theme override ── */
[data-theme="light"] {
  --void:       #f8f8ff;
  --deep:       #f0f0f8;
  --panel:      #ffffff;
  --surface:    #eeeef8;
  --surface-hi: #e4e4f0;
  --border:     rgba(0,0,0,0.08);
  --border-hi:  rgba(0,0,0,0.14);

  --gold:       #c47a00;
  --gold-dim:   rgba(196,122,0,0.12);
  --gold-glow:  rgba(196,122,0,0.28);
  --teal:       #007a62;
  --teal-dim:   rgba(0,122,98,0.10);
  --violet:     #6a44cc;
  --violet-dim: rgba(106,68,204,0.10);
  --rose:       #c42040;
  --rose-dim:   rgba(196,32,64,0.10);
  --sky:        #0070b8;
  --sky-dim:    rgba(0,112,184,0.10);

  --text:       #12121e;
  --text-dim:   #505070;
  --text-faint: #6868a0;

  --navy:       #003865;
  --navy-mid:   #00498a;

  --glow-gold:  0 0 12px rgba(196,122,0,0.15);
  --glow-teal:  0 0 12px rgba(0,122,98,0.12);
}

/* ── Suite theme toggle button ── */
.suite-nav-guide {
  font-size: 0.68rem;
  font-weight: 600;
  letter-spacing: 0.05em;
  color: var(--gold);
  text-decoration: none;
  padding: 3px 10px;
  border-radius: 20px;
  border: 1px solid rgba(245,192,106,0.4);
  background: rgba(245,192,106,0.08);
  transition: background 0.18s, border-color 0.18s, color 0.18s;
  flex-shrink: 0;
}
.suite-nav-guide:hover { background: rgba(245,192,106,0.18); border-color: rgba(245,192,106,0.65); color: #fdd28a; }

.btn-suite-theme {
  background: transparent;
  border: 1px solid rgba(128,128,128,0.25);
  border-radius: 20px;
  padding: 4px 10px;
  font-size: 0.82rem;
  cursor: pointer;
  color: inherit;
  opacity: 0.65;
  transition: opacity 0.2s, background 0.2s;
  line-height: 1;
  flex-shrink: 0;
}
.btn-suite-theme:hover { opacity: 1; background: rgba(128,128,128,0.12); }

  /* App shell: full-width main, panel as bottom drawer */
  .app-shell {
    flex-direction: column;
    position: relative;
  }

  .context-panel {
    position: fixed;
    bottom: 0; left: 0; right: 0;
    width: 100% !important;
    max-height: 72vh;
    z-index: 200;
    border-right: none;
    border-top: 1px solid rgba(255,255,255,0.12);
    border-radius: 16px 16px 0 0;
    transform: translateY(100%);
    transition: transform 0.3s cubic-bezier(0.4,0,0.2,1);
    overflow-y: auto;
  }
  .context-panel.mobile-open { transform: translateY(0); }

  .main-content { flex: 1; width: 100%; }

  /* Activity ribbon: scrollable row */
  .activity-ribbon {
    gap: 6px;
    padding: 0 10px;
    justify-content: flex-start;
  }
  .activity-tile { flex-shrink: 0; padding: 8px 10px; }
  .tile-tag { display: none; }

  /* Stage: ensure it fills height minus bars */
  .stage { padding: 12px; }

  /* Generate bar */
  .generate-bar { padding: 10px 12px; gap: 8px; }
  .btn-share, .btn-save, .btn-regen { padding: 0 10px; font-size: 0.72rem; }

  /* Mobile open-panel button */
  .btn-open-panel {
    display: flex !important;
    position: fixed;
    bottom: 72px; left: 16px;
    width: 44px; height: 44px;
    border-radius: 50%;
    background: var(--gold);
    border: none;
    color: #000;
    font-size: 1.2rem;
    align-items: center; justify-content: center;
    box-shadow: 0 4px 16px rgba(0,0,0,0.4);
    z-index: 210;
    cursor: pointer;
  }

  /* Backdrop */
  .mobile-backdrop {
    display: none;
    position: fixed; inset: 0;
    background: rgba(0,0,0,0.55);
    z-index: 199;
  }
  .mobile-backdrop.visible { display: block; }

  /* Concept map on mobile: cap height */
  #concept-svg-container { min-height: 300px; }
  #concept-svg { min-height: 300px; }
  .map-detail-panel.open { width: 100%; position: fixed; bottom: 0; left: 0; right: 0; max-height: 50vh; z-index: 201; border-radius: 16px 16px 0 0; }
  .map-detail-inner { min-height: unset; border-radius: 16px 16px 0 0; }

  /* Topbar compact */
  .topbar { padding: 0 12px; }
  .topbar-title { font-size: 0.85rem; }
  .topbar-lab-badge { display: none; }
}

</style>
<!-- PDF.js for client-side PDF text extraction -->
<script type="module">
  import * as pdfjs from 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.4.168/build/pdf.min.mjs';
  pdfjs.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.4.168/build/pdf.worker.min.mjs';
  window.pdfjsLib = pdfjs;
</script>
<!-- mammoth.js for client-side .docx text extraction -->
<script src="https://cdn.jsdelivr.net/npm/mammoth@1.8.0/mammoth.browser.min.js"></script>
</head>
<body>

<!-- TOPBAR -->
<header class="topbar" role="banner">
  <div class="topbar-brand">
    <img src="https://openpress.trubox.ca/wp-content/uploads/sites/2142/2023/10/cropped-openpress_logo_colour-1.png"
         alt="TRU Open Press" class="topbar-logo"
         onerror="this.style.display='none'">
    <div class="brand-text">
      <span class="brand-nova">Nova</span>
      <span class="brand-sub">Experimental OER Lab · TRU Open Press</span>
    </div>
  </div>
  <div class="topbar-right">
    <div class="status-pill" id="status-pill">
      <span class="status-dot"></span>
      <span id="status-text">Not connected</span>
    </div>
    <span class="topbar-lab-badge">✦ Lab Build</span>
  </div>
</header>

<!-- SUITE NAV -->
<nav class="suite-nav" aria-label="Open Margins suite">
  <a href="../index.html" class="suite-nav-home">← Open Margins</a>
  <div class="suite-nav-tools">
    <a href="../companion/companion.html" class="suite-nav-pill pill-companion">✦ Companion</a>
    <a href="../tru-oer-activity-builder.html" class="suite-nav-pill pill-builder">⬡ Activity Builder</a>
    <span class="suite-nav-pill pill-nova pill-active" aria-current="page">✺ Nova</span>
    <a href="../rhizo/rhizo.html" class="suite-nav-pill pill-rhizo">∿ Rhizo</a>
    <a href="../sylva/sylva.html" class="suite-nav-pill pill-sylva">⟡ Sylva</a>
  </div>
  <a href="nova-guide.html" class="suite-nav-guide" title="Nova guide — how to use each activity" aria-label="Nova guide">? guide</a>
  <button class="btn-suite-theme" id="btn-suite-theme" aria-label="Toggle theme" title="Toggle theme">🌙</button>
</nav>

<div class="app-shell">

  <!-- LEFT: Context Panel -->
  <aside class="context-panel" aria-label="OER Content and Settings">

    <div class="context-header">
      <div class="section-label">Proxy Server</div>
      <div class="proxy-row">
        <input type="url" class="proxy-input" id="proxy-url"
               value="http://localhost:3001/api/generate"
               placeholder="http://localhost:3001/api/generate"
               aria-label="Proxy server URL">
        <button class="btn-connect" id="btn-connect" type="button">Connect</button>
      </div>
      <div style="font-size:0.68rem;color:var(--text-dim);margin-top:4px;" id="connect-msg">Connecting…</div>
    </div>

    <div class="context-body">

      <!-- ── BOOK BROWSER ── -->
      <div id="book-browser">

        <!-- Book list view -->
        <div id="book-list-view">
          <div class="books-loading" id="books-loading">
            <div class="books-spinner"></div>
            <span>Loading TRU Open Press books…</span>
          </div>

          <div id="books-ready" class="hidden">
            <input type="search" class="book-search" id="book-search"
                   placeholder="Search by title, subject, or author…"
                   aria-label="Search books">
            <div class="book-count" id="book-count"></div>
            <div class="book-list" id="book-list" role="listbox" aria-label="TRU Open Press books"></div>
          </div>

          <div id="books-error" class="books-error hidden">
            Could not load books. <button class="books-retry-btn" id="books-retry">Retry</button>
          </div>
        </div>

        <!-- Focus view: selected book + chapter picker -->
        <div id="book-focus-view" class="hidden">
          <button class="book-back-btn" id="book-back" type="button" aria-label="Change book">
            ← Change book
          </button>

          <div class="selected-book-card" id="selected-book-card"></div>

          <!-- TOC loading -->
          <div class="toc-loading hidden" id="toc-loading">
            <div class="books-spinner"></div>
            <span>Loading chapters…</span>
          </div>

          <!-- Part + Chapter selectors -->
          <div id="toc-selectors" class="hidden">
            <label class="text-area-label" for="part-select">Part</label>
            <select class="toc-select" id="part-select" aria-label="Select a part">
              <option value="">— select a part —</option>
            </select>

            <label class="text-area-label" for="chapter-select" style="margin-top:10px">Chapter</label>
            <select class="toc-select" id="chapter-select" aria-label="Select a chapter" disabled>
              <option value="">— select a chapter —</option>
            </select>

            <div id="chapter-meta" class="chapter-meta hidden"></div>

            <button class="btn-load-chapter hidden" id="btn-load-chapter" type="button">
              + Add chapter to sources
            </button>
          </div>

          <div id="chapter-notice" class="chapter-notice hidden"></div>
        </div>

      </div>

      <!-- ── SOURCE TRAY ── -->
      <div id="source-tray" class="source-tray"></div>

      <!-- ── URL FETCH ── -->
      <div class="oer-source-sep">Fetch from URL</div>
      <div class="url-fetch-row">
        <input type="url" class="url-fetch-input" id="url-fetch-input"
               placeholder="https://example.com/article"
               aria-label="URL to fetch text from">
        <button class="btn-fetch-url" id="btn-fetch-url" type="button">Fetch</button>
      </div>
      <div class="url-fetch-status" id="url-fetch-status"></div>

      <!-- ── FILE UPLOAD ── -->
      <div class="oer-source-sep">Upload PDF or Word doc</div>
      <button class="file-upload-btn" id="btn-file-upload" type="button">
        ↑ Upload PDF or .docx file
      </button>
      <div class="file-upload-status" id="file-upload-status"></div>
      <input type="file" id="file-upload-input" accept=".pdf,.docx,application/pdf,application/vnd.openxmlformats-officedocument.wordprocessingml.document">

      <!-- ── PASTE FALLBACK ── -->
      <div class="context-divider" id="paste-divider"></div>
      <div id="paste-toggle-row">
        <button class="paste-toggle-btn" id="paste-toggle" type="button">
          ✎ Paste text instead
        </button>
      </div>

      <div id="paste-section" class="hidden">
        <label class="text-area-label" for="oer-text" style="margin-top:8px">OER Content <span style="color:var(--text-dim);font-weight:400">(paste chapter text)</span></label>
        <textarea class="oer-textarea" id="oer-text"
          placeholder="Paste a chapter or section from any TRU Open Press book here.

Aim for 300–1200 words for best results."></textarea>
        <div class="word-count"><span id="word-count">0</span> words</div>
      </div>

      <div class="context-divider"></div>

      <label class="text-area-label" for="objective">Learning focus <span style="color:var(--text-dim);font-weight:400">(optional)</span></label>
      <input type="text" class="objective-input" id="objective"
             placeholder="e.g. Help students connect cause and effect">
    </div>

  </aside>

  <!-- CENTRE: Stage -->
  <div class="centre">

    <!-- Activity Ribbon -->
    <div class="activity-ribbon" role="tablist" aria-label="Activity types">

      <button class="activity-tile active" data-activity="conceptmap" role="tab" aria-selected="true"
              style="--tile-color:var(--gold);--tile-bg:var(--gold-dim);--tile-glow:var(--gold-glow)">
        <span class="tile-icon">🕸</span>
        <span class="tile-name">Concept Map</span>
        <span class="tile-tag">visual</span>
      </button>

      <button class="activity-tile" data-activity="socratic" role="tab" aria-selected="false"
              style="--tile-color:var(--teal);--tile-bg:var(--teal-dim);--tile-glow:rgba(0,212,170,0.4)">
        <span class="tile-icon">🦉</span>
        <span class="tile-name">Socratic Tutor</span>
        <span class="tile-tag">dialogue</span>
      </button>

      <button class="activity-tile" data-activity="tribunal" role="tab" aria-selected="false"
              style="--tile-color:var(--violet);--tile-bg:var(--violet-dim);--tile-glow:rgba(167,139,250,0.4)">
        <span class="tile-icon">⚖️</span>
        <span class="tile-name">Evidence Tribunal</span>
        <span class="tile-tag">critical thinking</span>
      </button>

      <button class="activity-tile" data-activity="analogy" role="tab" aria-selected="false"
              style="--tile-color:var(--sky);--tile-bg:var(--sky-dim);--tile-glow:rgba(56,189,248,0.4)">
        <span class="tile-icon">🔥</span>
        <span class="tile-name">Analogy Forge</span>
        <span class="tile-tag">deep thinking</span>
      </button>

      <button class="activity-tile" data-activity="timeline" role="tab" aria-selected="false"
              style="--tile-color:var(--rose);--tile-bg:var(--rose-dim);--tile-glow:rgba(251,113,133,0.4)">
        <span class="tile-icon">📍</span>
        <span class="tile-name">Concept Timeline</span>
        <span class="tile-tag">sequence</span>
      </button>

      <button class="activity-tile" data-activity="assumptions" role="tab" aria-selected="false"
              style="--tile-color:var(--violet);--tile-bg:var(--violet-dim);--tile-glow:rgba(167,139,250,0.4)">
        <span class="tile-icon">🔍</span>
        <span class="tile-name">Assumption Excavator</span>
        <span class="tile-tag">critical</span>
      </button>

      <button class="activity-tile" data-activity="transfer" role="tab" aria-selected="false"
              style="--tile-color:var(--teal);--tile-bg:var(--teal-dim);--tile-glow:rgba(0,212,170,0.4)">
        <span class="tile-icon">🌐</span>
        <span class="tile-name">Transfer Challenge</span>
        <span class="tile-tag">application</span>
      </button>

      <button class="activity-tile" data-activity="questions" role="tab" aria-selected="false"
              style="--tile-color:var(--gold);--tile-bg:var(--gold-dim);--tile-glow:var(--gold-glow)">
        <span class="tile-icon">❓</span>
        <span class="tile-name">Question Generator</span>
        <span class="tile-tag">metacognitive</span>
      </button>

    </div>

    <!-- Stage Area -->
    <div class="stage" id="stage">

      <!-- Idle / Welcome -->
      <div class="stage-idle" id="stage-idle">
        <div class="idle-nova-mark" aria-hidden="true">N</div>
        <h1 class="idle-title">Eight ways to go deeper into any OER chapter</h1>
        <p class="idle-sub">Select a TRU Open Press book and chapter in the left panel, pick an activity type above, and hit Generate. Nova uses AI to create interactive experiences that go well beyond quizzes.</p>
        <div class="idle-tiles" aria-hidden="true">
          <span class="idle-tile-hint">🕸 Map concepts visually</span>
          <span class="idle-tile-hint">🦉 Be questioned Socratically</span>
          <span class="idle-tile-hint">⚖️ Weigh evidence</span>
          <span class="idle-tile-hint">🔥 Forge analogies</span>
          <span class="idle-tile-hint">📍 Walk a timeline</span>
          <span class="idle-tile-hint">🔍 Excavate assumptions</span>
          <span class="idle-tile-hint">🌐 Transfer to new contexts</span>
          <span class="idle-tile-hint">❓ Generate your own questions</span>
        </div>
      </div>

    </div>

    <!-- Generate Bar -->
    <div class="generate-bar">
      <div class="generate-bar-inner">
        <div class="generate-btn-row">
          <button class="btn-generate" id="btn-generate" disabled>
            <span class="spark" aria-hidden="true">✦</span>
            <span id="generate-label">Generate Concept Map</span>
          </button>
          <button class="btn-regenerate hidden" id="btn-regenerate" title="Regenerate this activity" aria-label="Regenerate">
            ⟳
          </button>
          <button class="btn-share hidden" id="btn-share" type="button"
                  title="Copy a shareable link to this activity"
                  aria-label="Copy shareable link">
            <span>⤴ Share</span>
          </button>
          <button class="btn-save hidden" id="btn-save" type="button"
                  title="Download this session as markdown"
                  aria-label="Save session">
            <span>↓ Save</span>
          </button>
        </div>
        <div class="generate-hint" id="generate-hint" aria-live="polite">Connect to proxy first</div>
      </div>
    </div>

  </div>
</div>

<!-- Mobile panel toggle button (visible on small screens only) -->
<button class="btn-open-panel" id="btn-open-panel" style="display:none" aria-label="Open source panel" aria-expanded="false">📚</button>
<div class="mobile-backdrop" id="mobile-backdrop"></div>

<!-- Node tooltip (shared) -->
<div id="node-tooltip" role="tooltip" aria-hidden="true">
  <div class="tt-title" id="tt-title"></div>
  <div class="tt-body" id="tt-body"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>
<script>
// ══════════════════════════════════════════════════════════
//  NOVA — State & Constants
// ══════════════════════════════════════════════════════════

const PROXY_BASE = 'http://localhost:3001';
const ACTIVITY_LABELS = {
  conceptmap:  'Generate Concept Map',
  socratic:    'Start Socratic Session',
  tribunal:    'Convene Tribunal',
  analogy:     'Forge an Analogy',
  timeline:    'Build Concept Timeline',
  assumptions: 'Excavate Assumptions',
  transfer:    'Generate Transfer Scenarios',
  questions:   'Generate Questions',
};

// ── SHARE / HASH ──
const SHAREABLE_ACTIVITIES = new Set(['conceptmap', 'tribunal', 'analogy', 'timeline', 'assumptions', 'transfer', 'questions']);

const ACTIVITY_META = {
  conceptmap:  { icon: '🕸', label: 'Concept Map' },
  tribunal:    { icon: '⚖️', label: 'Evidence Tribunal' },
  analogy:     { icon: '🔥', label: 'Analogy Forge' },
  timeline:    { icon: '📍', label: 'Concept Timeline' },
  assumptions: { icon: '🔍', label: 'Assumption Excavator' },
  transfer:    { icon: '🌐', label: 'Transfer Challenge' },
  questions:   { icon: '❓', label: 'Question Generator' },
};

let state = {
  activity: 'conceptmap',
  connected: false,
  // Pressbooks book browser
  bookUrl: null,
  bookTitle: null,
  chapterId: null,
  loadedChapterText: null, // kept for compatibility
  allBooks: [],          // full list fetched from /api/books
  tocData: [],           // array of parts from /api/toc
  // Multi-source
  sources: [],           // [{ id, label, icon, text, wordCount }]
  // Socratic tutor
  socraticHistory: [],   // { role, content }
  socraticReady: false,
  generatedData: null,
};

// ══════════════════════════════════════════════════════════
//  UTILITIES
// ══════════════════════════════════════════════════════════

function esc(str) {
  return String(str ?? '')
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;');
}

function wordCount(txt) {
  return txt.trim() ? txt.trim().split(/\s+/).length : 0;
}

function getOerText() {
  const parts = [];
  state.sources.forEach(s => {
    parts.push(`=== ${s.label} ===\n${s.text}`);
  });
  const pasted = (document.getElementById('oer-text')?.value || '').trim();
  if (pasted) parts.push(`=== Pasted text ===\n${pasted}`);
  return parts.join('\n\n');
}

// ── Multi-source management ──────────────────────────────────────────────────

let _sourceIdCounter = 0;

function addSource(label, icon, text) {
  const wc = text.trim().split(/\s+/).filter(Boolean).length;
  const id  = ++_sourceIdCounter;
  state.sources.push({ id, label, icon, text, wordCount: wc });
  state.loadedChapterText = getOerText(); // keep compat ref updated
  renderSourceTray();
  setGenerateDisabled(!state.connected);
}

function removeSource(id) {
  state.sources = state.sources.filter(s => s.id !== id);
  state.loadedChapterText = state.sources.length ? getOerText() : null;
  renderSourceTray();
  if (!state.sources.length) {
    const pasted = (document.getElementById('oer-text')?.value || '').trim();
    setGenerateDisabled(!pasted || !state.connected);
  }
}

function renderSourceTray() {
  const tray = document.getElementById('source-tray');
  if (!tray) return;
  if (!state.sources.length) { tray.innerHTML = ''; return; }
  tray.innerHTML = state.sources.map(s => `
    <div class="source-chip" data-id="${s.id}">
      <span class="source-chip-icon">${s.icon}</span>
      <span class="source-chip-body">
        <span class="source-chip-label" title="${esc(s.label)}">${esc(s.label)}</span>
        <span class="source-chip-meta">${s.wordCount.toLocaleString()} words</span>
      </span>
      <button class="source-chip-remove" data-id="${s.id}" aria-label="Remove ${esc(s.label)}">✕</button>
    </div>`).join('');
  tray.querySelectorAll('.source-chip-remove').forEach(btn => {
    btn.addEventListener('click', () => removeSource(Number(btn.dataset.id)));
  });
}

async function fetchUrl() {
  const input  = document.getElementById('url-fetch-input');
  const status = document.getElementById('url-fetch-status');
  const btn    = document.getElementById('btn-fetch-url');
  const url    = input?.value.trim();
  if (!url) { status.textContent = 'Enter a URL first.'; status.className = 'url-fetch-status error'; return; }
  btn.disabled = true;
  status.textContent = 'Fetching…'; status.className = 'url-fetch-status';
  try {
    const res  = await fetch(`${getProxyBase()}/api/fetch-url?url=${encodeURIComponent(url)}`);
    const data = await res.json();
    if (!res.ok) throw new Error(data.error || `HTTP ${res.status}`);
    addSource(data.title || url, '🔗', data.text);
    status.textContent = `✓ Added "${data.title}" — ${(data.wordCount||0).toLocaleString()} words`;
    status.className = 'url-fetch-status success';
    input.value = '';
  } catch (err) {
    status.textContent = `Error: ${err.message}`;
    status.className = 'url-fetch-status error';
  } finally {
    btn.disabled = false;
  }
}

async function handleFileUpload(file) {
  const status = document.getElementById('file-upload-status');
  if (!file) return;
  status.textContent = `Reading ${file.name}…`; status.className = 'file-upload-status';
  try {
    const buf = await file.arrayBuffer();
    let text = '';
    if (file.name.toLowerCase().endsWith('.pdf')) {
      if (!window.pdfjsLib) throw new Error('PDF library not loaded yet. Try again in a moment.');
      const pdf    = await window.pdfjsLib.getDocument({ data: buf }).promise;
      const pages  = [];
      for (let i = 1; i <= pdf.numPages; i++) {
        const page    = await pdf.getPage(i);
        const content = await page.getTextContent();
        pages.push(content.items.map(it => it.str).join(' '));
      }
      text = pages.join('\n\n');
    } else if (file.name.toLowerCase().endsWith('.docx')) {
      if (!window.mammoth) throw new Error('Word library not loaded yet. Try again in a moment.');
      const result = await window.mammoth.extractRawText({ arrayBuffer: buf });
      text = result.value;
    } else {
      throw new Error('Only PDF and .docx files are supported.');
    }
    if (!text.trim()) throw new Error('No readable text found in file.');
    addSource(file.name, file.name.toLowerCase().endsWith('.pdf') ? '📄' : '📝', text);
    status.textContent = `✓ Added "${file.name}"`;
    status.className = 'file-upload-status success';
  } catch (err) {
    status.textContent = `Error: ${err.message}`;
    status.className = 'file-upload-status error';
  }
}
function getObjective() { return document.getElementById('objective').value.trim(); }
function getProxyUrl() { return document.getElementById('proxy-url').value.trim() || `${PROXY_BASE}/api/generate`; }
function getProxyBase() {
  // Strip /api/generate suffix to get root e.g. http://localhost:3001
  return getProxyUrl().replace(/\/api\/generate\/?$/, '');
}

function showStage(html) {
  const stage = document.getElementById('stage');
  stage.innerHTML = html;
}

function updateGenerateHint() {
  const hint = document.getElementById('generate-hint');
  if (!hint) return;
  if (!state.connected) {
    hint.textContent = '⚠ Connect to proxy first';
  } else if (!getOerText()) {
    hint.textContent = '⚠ Load a chapter or paste text first';
  } else {
    hint.textContent = '';
  }
}

function setGenerateDisabled(disabled) {
  const btn = document.getElementById('btn-generate');
  if (!btn) return;
  btn.disabled = disabled;
  updateGenerateHint();
}

function showGenerating(what) {
  showStage(`
    <div class="generating-overlay">
      <div class="nova-spinner" aria-hidden="true"></div>
      <div class="gen-title">Claude is thinking…</div>
      <p class="gen-sub">${esc(what)}</p>
    </div>`);
}

function showError(msg) {
  showStage(`
    <div class="error-state">
      <div class="error-icon" aria-hidden="true">⚡</div>
      <div class="error-title">Generation failed</div>
      <p class="error-msg">${esc(msg)}</p>
    </div>`);
  setGenerateDisabled(false);
}

function showIdleStage() {
  state.generatedData = null;
  showStage(`
    <div class="stage-idle" id="stage-idle">
      <div class="idle-nova-mark" aria-hidden="true">N</div>
      <h1 class="idle-title">Eight ways to go deeper into any OER chapter</h1>
      <p class="idle-sub">Select a TRU Open Press book and chapter in the left panel, pick an activity type above, and hit Generate. Nova uses AI to create interactive experiences that go well beyond quizzes.</p>
      <div class="idle-tiles" aria-hidden="true">
        <span class="idle-tile-hint">🕸 Map concepts visually</span>
        <span class="idle-tile-hint">🦉 Be questioned Socratically</span>
        <span class="idle-tile-hint">⚖️ Weigh evidence</span>
        <span class="idle-tile-hint">🔥 Forge analogies</span>
        <span class="idle-tile-hint">📍 Walk a timeline</span>
        <span class="idle-tile-hint">🔍 Excavate assumptions</span>
        <span class="idle-tile-hint">🌐 Transfer to new contexts</span>
        <span class="idle-tile-hint">❓ Generate your own questions</span>
      </div>
    </div>`);
}

// ══════════════════════════════════════════════════════════
//  SHARE / HASH ENCODING
// ══════════════════════════════════════════════════════════

function encodeShare() {
  if (!state.generatedData || !SHAREABLE_ACTIVITIES.has(state.activity)) return null;
  const payload = JSON.stringify({ v: 1, a: state.activity, d: state.generatedData });
  let encoded;
  if (typeof LZString !== 'undefined') {
    encoded = LZString.compressToEncodedURIComponent(payload);
  } else {
    // btoa fallback — URL-safe base64
    encoded = btoa(unescape(encodeURIComponent(payload)))
      .replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
  }
  return window.location.href.split('#')[0] + '#share=' + encoded;
}

function decodeShare(hash) {
  if (!hash || !hash.startsWith('#share=')) return null;
  const encoded = hash.slice('#share='.length);
  if (!encoded) return null;
  try {
    let raw;
    if (typeof LZString !== 'undefined') {
      raw = LZString.decompressFromEncodedURIComponent(encoded);
    }
    if (!raw) {
      // atob fallback
      const padded = encoded.replace(/-/g, '+').replace(/_/g, '/');
      raw = decodeURIComponent(escape(atob(padded)));
    }
    if (!raw) return null;
    const payload = JSON.parse(raw);
    if (payload.v !== 1) return null;
    if (!SHAREABLE_ACTIVITIES.has(payload.a)) return null;
    if (!payload.d || typeof payload.d !== 'object') return null;
    return { activity: payload.a, data: payload.d };
  } catch (e) {
    return null;
  }
}

async function copyShareLink() {
  const url = encodeShare();
  if (!url) return;
  const btn = document.getElementById('btn-share');
  const originalHTML = btn.innerHTML;
  try {
    await navigator.clipboard.writeText(url);
    btn.innerHTML = '<span>✓ Copied!</span>';
    btn.classList.add('share-copied');
    setTimeout(() => {
      btn.innerHTML = originalHTML;
      btn.classList.remove('share-copied');
    }, 2000);
  } catch (e) {
    // Clipboard unavailable (file:// or permissions denied)
    prompt('Copy this share link:', url);
  }
}

function renderSharedActivity(activity, data) {
  // Restore state
  state.activity = activity;
  state.generatedData = data;

  // Highlight the correct activity tile
  document.querySelectorAll('.activity-tile').forEach(t => {
    const isActive = t.dataset.activity === activity;
    t.classList.toggle('active', isActive);
    t.setAttribute('aria-selected', isActive);
  });

  // Update generate button label
  const lbl = document.getElementById('generate-label');
  if (lbl) lbl.textContent = ACTIVITY_LABELS[activity] || 'Generate';

  // Show share, regenerate and save buttons
  document.getElementById('btn-share')?.classList.remove('hidden');
  document.getElementById('btn-regenerate')?.classList.remove('hidden');
  document.getElementById('btn-save')?.classList.remove('hidden');

  // Render the activity content (each render fn calls showStage() internally)
  switch (activity) {
    case 'conceptmap': renderConceptMap(data);  break;
    case 'tribunal':   renderTribunal(data);    break;
    case 'analogy':    renderAnalogy(data);     break;
    case 'timeline':   renderTimeline(data);    break;
  }

  // Inject shared banner AFTER render (showStage() replaces innerHTML, so must be after)
  const meta = ACTIVITY_META[activity] || { icon: '✦', label: activity };
  const stage = document.getElementById('stage');
  stage.insertAdjacentHTML('afterbegin', `
    <div class="shared-banner" id="shared-banner">
      <div class="shared-banner-left">
        <span class="shared-banner-icon" aria-hidden="true">${meta.icon}</span>
        <div class="shared-banner-text">
          <span class="shared-banner-label">Shared activity</span>
          <span class="shared-banner-title">${esc(meta.label)}</span>
        </div>
      </div>
      <button class="btn-generate-own" id="btn-generate-own" type="button">
        ✦ Generate your own
      </button>
    </div>`);

  // Wire "Generate your own"
  document.getElementById('btn-generate-own').addEventListener('click', () => {
    history.replaceState(null, '', window.location.pathname + window.location.search);
    document.getElementById('shared-banner')?.remove();
    showIdleStage();
    document.getElementById('btn-share')?.classList.add('hidden');
    document.getElementById('btn-regenerate')?.classList.add('hidden');
    document.getElementById('btn-save')?.classList.add('hidden');
    const lbl2 = document.getElementById('generate-label');
    if (lbl2) lbl2.textContent = ACTIVITY_LABELS[state.activity] || 'Generate';
  });
}

// ══════════════════════════════════════════════════════════
//  SAVE SESSION — collect visible content → markdown download
// ══════════════════════════════════════════════════════════

function _txt(selector) {
  const el = document.querySelector(selector);
  return el ? el.textContent.trim() : '';
}
function _val(selector) {
  const el = document.querySelector(selector);
  return (el && el.value) ? el.value.trim() : '';
}

function collectNovaSession() {
  const activity = state.activity;
  const meta  = ACTIVITY_META[activity] || { icon: '✦', label: activity };
  const book  = state.bookTitle || 'Unknown book';
  const ts    = new Date().toLocaleString();
  const lines = [];

  lines.push(`# Nova Session — ${meta.icon} ${meta.label}`);
  lines.push(`**Book:** ${book}  \n**Saved:** ${ts}\n`);
  lines.push('---\n');

  // ── Concept Map ──
  if (activity === 'conceptmap' && state.generatedData) {
    const d = state.generatedData;
    lines.push(`## ${d.title || 'Concept Map'}\n`);
    lines.push('### Concepts\n');
    (d.nodes || []).forEach(n => {
      lines.push(`**${n.label}** *(${n.type})*`);
      if (n.summary) lines.push(`> ${n.summary}`);
      lines.push('');
    });
    lines.push('### Relationships\n');
    (d.edges || []).forEach(e => {
      const from = (d.nodes||[]).find(n=>n.id===e.from)?.label || e.from;
      const to   = (d.nodes||[]).find(n=>n.id===e.to)?.label   || e.to;
      lines.push(`- **${from}** → *${e.label}* → **${to}**`);
    });
    lines.push('');
  }

  // ── Socratic Tutor ──
  else if (activity === 'socratic') {
    lines.push('## Socratic Dialogue\n');
    (state.socraticHistory || []).filter(m => m.role !== 'system').forEach(m => {
      const speaker = m.role === 'assistant' ? '🦉 **Tutor**' : '🧑‍🎓 **You**';
      lines.push(`${speaker}\n\n${m.content}\n`);
      lines.push('---\n');
    });
  }

  // ── Evidence Tribunal ──
  else if (activity === 'tribunal' && state.generatedData) {
    const d = state.generatedData;
    lines.push(`## The Claim\n\n> ${d.claim}\n`);
    if (d.context) lines.push(`*${d.context}*\n`);
    lines.push('### Arguments In Favour\n');
    (d.for || []).forEach((a, i) => {
      lines.push(`**${i+1}.** ${a.argument}  \n*Source: ${a.source}* — Strength: ${a.strength}/100\n`);
    });
    lines.push('### Arguments Against\n');
    (d.against || []).forEach((a, i) => {
      lines.push(`**${i+1}.** ${a.argument}  \n*Source: ${a.source}* — Strength: ${a.strength}/100\n`);
    });
    const liveLabel = _txt('#verdict-live-label');
    const reasoning = _val('#verdict-reasoning');
    if (liveLabel || reasoning) {
      lines.push('### Your Verdict\n');
      if (liveLabel) lines.push(`**Position:** ${liveLabel}\n`);
      if (reasoning) lines.push(`**Reasoning:** ${reasoning}\n`);
    }
    const feedback = _txt('#verdict-result-area .verdict-result-body');
    if (feedback) {
      lines.push("### Professor's Response\n");
      lines.push(`${feedback}\n`);
    }
  }

  // ── Analogy Forge ──
  else if (activity === 'analogy' && state.generatedData) {
    const d = state.generatedData;
    lines.push(`## Analogy: ${d.source_concept?.name} ↔ ${d.analogy_concept?.name}\n`);
    lines.push(`**OER Concept:** ${d.source_concept?.description || ''}\n`);
    lines.push(`**Analogy:** ${d.analogy_concept?.description || ''}\n`);
    lines.push('### Mappings\n');
    (d.mappings || []).forEach(m => {
      lines.push(`- **${m.source}** ↔ **${m.analogy}**`);
      if (m.relation) lines.push(`  *${m.relation}*`);
    });
    lines.push('');
    [
      { id: 'forge-extend',  label: '① Extend',   fbId: 'feedback-extend'  },
      { id: 'forge-break',   label: '② Break It',  fbId: 'feedback-break'   },
      { id: 'forge-rebuild', label: '③ Rebuild',   fbId: 'feedback-rebuild' },
    ].forEach(task => {
      const response = _val(`#${task.id}`);
      const feedback = _txt(`#${task.fbId}`);
      if (response || feedback) {
        lines.push(`### ${task.label}\n`);
        if (response) lines.push(`**Your response:** ${response}\n`);
        if (feedback) lines.push(`**Feedback:** ${feedback}\n`);
      }
    });
  }

  // ── Concept Timeline ──
  else if (activity === 'timeline' && state.generatedData) {
    const d = state.generatedData;
    lines.push(`## ${d.title || 'Concept Timeline'} *(${d.type || ''})*\n`);
    (d.items || []).forEach((item, i) => {
      lines.push(`### ${i+1}. ${item.era} — ${item.concept}\n`);
      lines.push(`${item.detail}\n`);
      const cardEl = document.getElementById(`tl-card-${i}`);
      if (cardEl && cardEl.dataset.revealed === 'true') {
        lines.push(`*Deeper question revealed:* ${item.reveals_on_click}\n`);
      }
    });
    const synthResponse = _val('#tl-synthesis-input');
    const synthFeedback = _txt('#synthesis-feedback');
    if (synthResponse || synthFeedback) {
      lines.push('### Synthesis Challenge\n');
      lines.push(`*${d.synthesis_question || ''}*\n`);
      if (synthResponse) lines.push(`**Your response:** ${synthResponse}\n`);
      if (synthFeedback) lines.push(`**Feedback:** ${synthFeedback}\n`);
    }
  }

  else {
    lines.push('*No session content captured yet.*\n');
  }

  lines.push('\n---\n*Generated by Nova — TRU Open Press Experimental OER Lab*');
  return lines.join('\n');
}

function saveNovaSession() {
  const md   = collectNovaSession();
  const meta = ACTIVITY_META[state.activity] || { label: 'session' };
  const slug = meta.label.toLowerCase().replace(/\s+/g, '-');
  const filename = `nova-${slug}-${Date.now()}.md`;
  const blob = new Blob([md], { type: 'text/markdown;charset=utf-8' });
  const url  = URL.createObjectURL(blob);
  const a    = document.createElement('a');
  a.href = url; a.download = filename;
  document.body.appendChild(a); a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  const btn = document.getElementById('btn-save');
  if (btn) {
    const orig = btn.innerHTML;
    btn.innerHTML = '<span>✓ Saved</span>';
    btn.classList.add('save-done');
    setTimeout(() => { btn.innerHTML = orig; btn.classList.remove('save-done'); }, 2000);
  }
}

async function callClaude(prompt, systemMsg = '') {
  const url = getProxyUrl();
  const fullPrompt = systemMsg ? `[SYSTEM]\n${systemMsg}\n\n[USER]\n${prompt}` : prompt;
  const res = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ prompt: fullPrompt }),
  });
  if (!res.ok) {
    const err = await res.text().catch(() => '');
    throw new Error(`Proxy returned HTTP ${res.status}. ${err || 'Check server logs.'}`);
  }
  const data = await res.json();
  const text = data?.content?.[0]?.text;
  if (!text) throw new Error('Claude returned no content. Check your proxy server.');
  return text;
}

function parseJSON(raw) {
  const cleaned = raw
    .replace(/^```(?:json)?\s*/im, '')
    .replace(/\s*```\s*$/im, '')
    .trim();
  return JSON.parse(cleaned);
}

// ══════════════════════════════════════════════════════════
//  BOOK BROWSER
// ══════════════════════════════════════════════════════════

async function loadBooks() {
  const loading = document.getElementById('books-loading');
  const ready   = document.getElementById('books-ready');
  const errDiv  = document.getElementById('books-error');

  loading.classList.remove('hidden');
  ready.classList.add('hidden');
  errDiv.classList.add('hidden');

  try {
    const res = await fetch(`${getProxyBase()}/api/books`);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const books = await res.json();
    state.allBooks = books.sort((a, b) => a.title.localeCompare(b.title));
    loading.classList.add('hidden');
    ready.classList.remove('hidden');
    renderBookList(state.allBooks);
  } catch (err) {
    loading.classList.add('hidden');
    errDiv.classList.remove('hidden');
    // Auto-open the paste panel so users can still work
    openPastePanel('Book library unavailable — paste your text below instead.');
  }
}

function openPastePanel(hintMsg) {
  const section = document.getElementById('paste-section');
  const btn     = document.getElementById('paste-toggle');
  if (!section.classList.contains('hidden')) return; // already open
  section.classList.remove('hidden');
  btn.classList.add('active');
  btn.textContent = '✕ Close paste panel';
  if (hintMsg) {
    // Show a small note above the textarea
    let note = document.getElementById('paste-auto-note');
    if (!note) {
      note = document.createElement('div');
      note.id = 'paste-auto-note';
      note.style.cssText = 'font-size:0.7rem;color:var(--rose);margin-bottom:8px;line-height:1.4;';
      section.insertBefore(note, section.firstChild);
    }
    note.textContent = hintMsg;
  }
}

function renderBookList(books) {
  const list  = document.getElementById('book-list');
  const count = document.getElementById('book-count');
  const total = state.allBooks.length;

  count.textContent = books.length === total
    ? `${total} book${total !== 1 ? 's' : ''}`
    : `${books.length} of ${total} books`;

  if (books.length === 0) {
    list.innerHTML = '<div style="font-size:0.78rem;color:var(--text-dim);padding:10px 0">No books match your search.</div>';
    return;
  }

  list.innerHTML = books.map(b => {
    const author = Array.isArray(b.author) && b.author.length
      ? b.author.map(a => a.name || a).join(', ')
      : (typeof b.author === 'string' ? b.author : '');
    const subject = Array.isArray(b.subject) ? b.subject[0] : b.subject;
    return `<button class="book-item" data-url="${esc(b.link)}" data-title="${esc(b.title)}" data-subject="${esc(subject||'')}">
      <div class="book-item-title">${esc(b.title)}</div>
      <div class="book-item-meta">
        ${subject ? `<span class="book-subject-badge">${esc(subject)}</span>` : ''}
        ${author ? `<span class="book-item-author">${esc(author)}</span>` : ''}
      </div>
    </button>`;
  }).join('');

  list.querySelectorAll('.book-item').forEach(btn => {
    btn.addEventListener('click', () =>
      selectBook(btn.dataset.url, btn.dataset.title, btn.dataset.subject));
  });
}

function filterBooks(query) {
  if (!query.trim()) {
    renderBookList(state.allBooks);
    return;
  }
  const q = query.toLowerCase();
  const filtered = state.allBooks.filter(b => {
    const title   = b.title?.toLowerCase() || '';
    const subject = Array.isArray(b.subject) ? b.subject.join(' ').toLowerCase() : (b.subject?.toLowerCase() || '');
    const author  = Array.isArray(b.author)
      ? b.author.map(a => a.name || a).join(' ').toLowerCase()
      : (b.author?.toLowerCase() || '');
    return title.includes(q) || subject.includes(q) || author.includes(q);
  });
  renderBookList(filtered);
}

function selectBook(bookUrl, bookTitle, bookSubject) {
  state.bookUrl   = bookUrl;
  state.bookTitle = bookTitle;
  state.chapterId = null;
  state.loadedChapterText = null;

  // Switch to focus view
  document.getElementById('book-list-view').classList.add('hidden');
  document.getElementById('book-focus-view').classList.remove('hidden');

  // Render selected book card
  document.getElementById('selected-book-card').innerHTML = `
    <div class="selected-book-title">${esc(bookTitle)}</div>
    ${bookSubject ? `<div class="selected-book-subject">${esc(bookSubject)}</div>` : ''}`;

  // Reset downstream state
  document.getElementById('toc-selectors').classList.add('hidden');
  document.getElementById('chapter-notice').classList.add('hidden');
  document.getElementById('chapter-notice').className = 'chapter-notice hidden';
  setGenerateDisabled(true);

  loadToc(bookUrl);
}

async function loadToc(bookUrl) {
  const loadingEl  = document.getElementById('toc-loading');
  const selectorsEl = document.getElementById('toc-selectors');

  loadingEl.classList.remove('hidden');
  selectorsEl.classList.add('hidden');

  try {
    const res = await fetch(`${getProxyBase()}/api/toc?bookUrl=${encodeURIComponent(bookUrl)}`);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const parts = await res.json();
    state.tocData = parts;
    loadingEl.classList.add('hidden');

    const partSel = document.getElementById('part-select');
    partSel.innerHTML = '<option value="">— select a part —</option>' +
      parts.map(p => `<option value="${esc(String(p.id))}">${esc(p.title)}</option>`).join('');

    const chSel = document.getElementById('chapter-select');
    chSel.innerHTML = '<option value="">— select a chapter —</option>';
    chSel.disabled = true;

    document.getElementById('chapter-meta').classList.add('hidden');
    document.getElementById('btn-load-chapter').classList.add('hidden');
    selectorsEl.classList.remove('hidden');
  } catch (err) {
    loadingEl.classList.add('hidden');
    const notice = document.getElementById('chapter-notice');
    notice.className = 'chapter-notice error';
    notice.textContent = `Could not load table of contents: ${err.message}`;
    notice.classList.remove('hidden');
  }
}

function onPartSelected() {
  const partId = document.getElementById('part-select').value;
  const chSel  = document.getElementById('chapter-select');
  document.getElementById('chapter-meta').classList.add('hidden');
  document.getElementById('btn-load-chapter').classList.add('hidden');
  document.getElementById('chapter-notice').classList.add('hidden');
  state.chapterId = null;

  if (!partId) {
    chSel.innerHTML = '<option value="">— select a chapter —</option>';
    chSel.disabled = true;
    setGenerateDisabled(true);
    return;
  }

  const part = state.tocData.find(p => String(p.id) === partId);
  if (!part || !part.chapters?.length) {
    chSel.innerHTML = '<option value="">No chapters available</option>';
    chSel.disabled = true;
    return;
  }

  chSel.innerHTML = '<option value="">— select a chapter —</option>' +
    part.chapters.map(c => {
      const wc = c.wordCount ? ` (${Number(c.wordCount).toLocaleString()} words)` : '';
      return `<option value="${esc(String(c.id))}" data-link="${esc(c.link||'')}" data-wc="${esc(String(c.wordCount||0))}">${esc(c.title)}${wc}</option>`;
    }).join('');
  chSel.disabled = false;
}

function onChapterSelected() {
  const chSel = document.getElementById('chapter-select');
  const opt   = chSel.selectedOptions[0];

  document.getElementById('chapter-meta').classList.add('hidden');
  document.getElementById('btn-load-chapter').classList.add('hidden');
  document.getElementById('chapter-notice').classList.add('hidden');
  state.chapterId = null;
  const hasSource = state.sources.length > 0 || (document.getElementById('oer-text')?.value || '').trim();
  setGenerateDisabled(!hasSource || !state.connected);

  if (!chSel.value) return;

  state.chapterId = chSel.value;
  const wc   = opt?.dataset.wc;
  const link = opt?.dataset.link;

  // Show metadata
  const metaEl = document.getElementById('chapter-meta');
  metaEl.innerHTML =
    (wc && wc !== '0' ? `<span class="chapter-wc-pill">${Number(wc).toLocaleString()} words</span>` : '') +
    (link ? `<a class="chapter-link" href="${esc(link)}" target="_blank" rel="noopener">View in Pressbooks ↗</a>` : '');
  metaEl.classList.remove('hidden');

  document.getElementById('btn-load-chapter').classList.remove('hidden');
}

async function loadChapter() {
  const btn    = document.getElementById('btn-load-chapter');
  const notice = document.getElementById('chapter-notice');
  btn.disabled = true;
  btn.textContent = 'Adding…';
  notice.classList.add('hidden');

  try {
    const url = `${getProxyBase()}/api/chapter?bookUrl=${encodeURIComponent(state.bookUrl)}&chapterId=${encodeURIComponent(state.chapterId)}`;
    const res = await fetch(url);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    if (!data.text) throw new Error('No text returned from server.');

    const chapterTitle = data.title || document.getElementById('chapter-select').selectedOptions[0]?.text || 'Chapter';
    addSource(chapterTitle, '📖', data.text);
    const wc = data.wordCount || data.text.split(/\s+/).filter(Boolean).length;

    notice.className = 'chapter-notice success';
    notice.textContent = `✓ Added "${chapterTitle}" — ${Number(wc).toLocaleString()} words`;
    notice.classList.remove('hidden');
  } catch (err) {
    notice.className = 'chapter-notice error';
    notice.textContent = `Failed to load chapter: ${err.message}`;
    notice.classList.remove('hidden');
  } finally {
    btn.disabled = false;
    btn.textContent = '+ Add chapter to sources';
  }
}

// ══════════════════════════════════════════════════════════
//  CONNECTION TEST
// ══════════════════════════════════════════════════════════

async function testConnection() {
  const pill = document.getElementById('status-pill');
  const txt = document.getElementById('status-text');
  const msg = document.getElementById('connect-msg');
  const btn = document.getElementById('btn-connect');
  btn.disabled = true;
  btn.textContent = '…';
  txt.textContent = 'Connecting…';
  msg.textContent = 'Connecting to proxy…'; msg.style.color = 'var(--text-dim)';

  try {
    const healthUrl = (getProxyBase() || window.location.origin) + '/api/health';
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 5000);
    const res = await fetch(healthUrl, { signal: controller.signal }).finally(() => clearTimeout(timeout));
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    if (data?.status !== 'ok') throw new Error('Unexpected response');
    state.connected = true;
    pill.classList.add('connected');
    txt.textContent = 'Claude connected';
    msg.textContent = 'AI generation ready. Select a book and chapter below.';
    msg.style.color = 'var(--teal)';
    setGenerateDisabled(!getOerText());
    // Auto-load book list on first successful connection
    if (state.allBooks.length === 0) loadBooks();
  } catch (err) {
    state.connected = false;
    pill.classList.remove('connected');
    txt.textContent = 'Not connected';
    msg.innerHTML = `Can't reach proxy (${err.message}). Is the server running? In Terminal: <code style="color:var(--gold)">node server.js</code>`;
    msg.style.color = 'var(--rose)';
  } finally {
    btn.disabled = false;
    btn.textContent = 'Connect';
  }
}

// ══════════════════════════════════════════════════════════
//  ACTIVITY SELECTION
// ══════════════════════════════════════════════════════════

function selectActivity(name) {
  state.activity = name;
  document.querySelectorAll('.activity-tile').forEach(t => {
    const isActive = t.dataset.activity === name;
    t.classList.toggle('active', isActive);
    t.setAttribute('aria-selected', isActive);
  });
  const lbl = document.getElementById('generate-label');
  if (lbl) lbl.textContent = ACTIVITY_LABELS[name] || 'Generate';

  // Hide regenerate + share + save — this activity hasn't been generated yet
  document.getElementById('btn-regenerate')?.classList.add('hidden');
  document.getElementById('btn-share')?.classList.add('hidden');
  document.getElementById('btn-save')?.classList.add('hidden');

  // Reset stage to idle whenever the user switches activity
  showIdleStage();
}

// ══════════════════════════════════════════════════════════
//  DISPATCH
// ══════════════════════════════════════════════════════════

async function generate() {
  const text = getOerText();
  if (!text) {
    showError('No content to generate from. Load a chapter or paste text in the left panel.');
    return;
  }
  if (!state.connected) {
    showError('Please connect to the proxy server first (click Connect).');
    return;
  }

  const genBtn    = document.getElementById('btn-generate');
  const regenBtn  = document.getElementById('btn-regenerate');
  const shareBtn  = document.getElementById('btn-share');
  const saveBtn   = document.getElementById('btn-save');
  genBtn.disabled = true;
  regenBtn.classList.add('hidden');
  shareBtn?.classList.add('hidden');
  saveBtn?.classList.add('hidden');
  document.getElementById('stage-idle')?.remove();

  try {
    switch (state.activity) {
      case 'conceptmap':  await generateConceptMap(text); break;
      case 'socratic':    await startSocratic(text); break;
      case 'tribunal':    await generateTribunal(text); break;
      case 'analogy':     await generateAnalogy(text); break;
      case 'timeline':    await generateTimeline(text); break;
      case 'assumptions': await generateAssumptions(text); break;
      case 'transfer':    await generateTransfer(text); break;
      case 'questions':   await generateQuestions(text); break;
    }
    // Show regenerate + share + save buttons on success (socratic gets save too)
    if (state.activity !== 'socratic') {
      regenBtn.classList.remove('hidden');
      if (SHAREABLE_ACTIVITIES.has(state.activity)) shareBtn?.classList.remove('hidden');
    }
    saveBtn?.classList.remove('hidden');
  } catch (err) {
    showError(err.message);
  } finally {
    // Re-enable so user can regenerate (showError also re-enables, so this is the success path)
    if (state.activity !== 'socratic') setGenerateDisabled(false);
  }
}

// ══════════════════════════════════════════════════════════
//  ACTIVITY 1: CONCEPT MAP
// ══════════════════════════════════════════════════════════

async function generateConceptMap(text) {
  const obj = getObjective();
  showGenerating('Reading your OER and extracting key concepts and their relationships…');

  const prompt = `You are a knowledge-graph expert. Analyse this OER excerpt and extract a rich concept map.

OER TEXT:
---
${text}
---
${obj ? `\nFocus on: ${obj}` : ''}

Return ONLY valid JSON (no markdown, no fences) with this structure:
{
  "title": "Short title for this concept map",
  "nodes": [
    { "id": "n1", "label": "Concept Name", "type": "core|supporting|example|process", "summary": "1-2 sentence explanation of this concept from the text" }
  ],
  "edges": [
    { "from": "n1", "to": "n2", "label": "relationship label (2-5 words)", "type": "causes|leads_to|is_a|part_of|contrasts_with|requires|produces" }
  ]
}

Rules:
- 8–16 nodes total. Exactly 1–3 "core" nodes (the central ideas). The rest supporting/example/process.
- 10–20 edges, each with a meaningful label
- Labels should be short (1–4 words)
- Summaries should quote or paraphrase the source text`;

  const raw = await callClaude(prompt);
  const data = parseJSON(raw);

  state.generatedData = data;
  renderConceptMap(data);
  setGenerateDisabled(false);
}

function renderConceptMap(data) {
  const { title, nodes, edges } = data;

  const svgW = 900, svgH = 560;
  const cx = svgW / 2, cy = svgH / 2;

  // ── Improved force-directed layout ──────────────────────────
  const pos = {};
  const core = nodes.filter(n => n.type === 'core');
  const rest = nodes.filter(n => n.type !== 'core');

  // Initial placement: cores clustered at centre, others in rings
  core.forEach((n, i) => {
    const a = (2 * Math.PI * i / Math.max(core.length, 1)) - Math.PI / 2;
    const r = core.length > 1 ? 85 : 0;
    pos[n.id] = { x: cx + r * Math.cos(a), y: cy + r * Math.sin(a) };
  });
  rest.forEach((n, i) => {
    const a = (2 * Math.PI * i / rest.length) - Math.PI / 6;
    const r = 185 + (i % 4) * 45;
    pos[n.id] = { x: cx + r * Math.cos(a), y: cy + r * Math.sin(a) };
  });

  // Build adjacency for edge attraction
  const adj = {};
  nodes.forEach(n => { adj[n.id] = []; });
  edges.forEach(e => {
    if (adj[e.from]) adj[e.from].push(e.to);
    if (adj[e.to])   adj[e.to].push(e.from);
  });

  const typeR = { core: 52, supporting: 42, process: 40, example: 36 };

  // Force simulation: 40 iterations, repulsion + edge attraction + centre gravity
  for (let iter = 0; iter < 40; iter++) {
    const force = {};
    nodes.forEach(n => { force[n.id] = { x: 0, y: 0 }; });

    // Repulsion between all node pairs
    nodes.forEach(a => {
      nodes.forEach(b => {
        if (a.id === b.id) return;
        const pa = pos[a.id], pb = pos[b.id];
        const dx = pa.x - pb.x, dy = pa.y - pb.y;
        const dist = Math.sqrt(dx*dx + dy*dy) || 1;
        const minD = (typeR[a.type]||42) + (typeR[b.type]||42) + 40;
        if (dist < minD) {
          const f = (minD - dist) / dist * 0.5;
          force[a.id].x += dx * f;
          force[a.id].y += dy * f;
          force[b.id].x -= dx * f;
          force[b.id].y -= dy * f;
        }
      });
    });

    // Edge attraction — connected nodes pull toward each other
    edges.forEach(e => {
      const pa = pos[e.from], pb = pos[e.to];
      if (!pa || !pb) return;
      const dx = pb.x - pa.x, dy = pb.y - pa.y;
      const dist = Math.sqrt(dx*dx + dy*dy) || 1;
      const ideal = 200;
      if (dist > ideal) {
        const f = (dist - ideal) / dist * 0.12;
        force[e.from].x += dx * f;
        force[e.from].y += dy * f;
        force[e.to].x -= dx * f;
        force[e.to].y -= dy * f;
      }
    });

    // Gentle centre gravity for non-core nodes
    nodes.filter(n => n.type !== 'core').forEach(n => {
      const pa = pos[n.id];
      force[n.id].x += (cx - pa.x) * 0.01;
      force[n.id].y += (cy - pa.y) * 0.01;
    });

    // Apply forces, keep in bounds
    const cooling = 1 - iter / 60;
    nodes.forEach(n => {
      const p = pos[n.id], f = force[n.id];
      p.x += f.x * cooling;
      p.y += f.y * cooling;
      const pad = (typeR[n.type]||42) + 10;
      p.x = Math.max(pad, Math.min(svgW - pad, p.x));
      p.y = Math.max(pad + 10, Math.min(svgH - pad, p.y));
    });
  }

  const typeColours = {
    core:       { fill: '#003865', stroke: '#f5a623', text: '#f5a623', r: 52 },
    supporting: { fill: '#1a1a2e', stroke: '#00d4aa', text: '#00d4aa', r: 42 },
    process:    { fill: '#1a1a2e', stroke: '#a78bfa', text: '#a78bfa', r: 40 },
    example:    { fill: '#12121f', stroke: '#38bdf8', text: '#38bdf8', r: 36 },
  };
  const edgeColours = {
    causes: '#fb7185', leads_to: '#f5a623', is_a: '#00d4aa',
    part_of: '#38bdf8', contrasts_with: '#a78bfa',
    requires: '#fdc85a', produces: '#00d4aa', default: '#888899',
  };

  // Helper: word-wrap label at ~14 chars
  function wrapLabel(label) {
    const words = label.split(' ');
    const lines = []; let line = '';
    words.forEach(w => {
      const test = line ? `${line} ${w}` : w;
      if (test.length > 14 && line) { lines.push(line); line = w; }
      else line = test;
    });
    if (line) lines.push(line);
    return lines;
  }

  // ── SVG string construction ──────────────────────────────────
  const arrowTypes = ['causes','leads_to','is_a','part_of','contrasts_with','requires','produces','default'];
  const defs = arrowTypes.map(t => {
    const col = edgeColours[t] || '#888';
    return `<marker id="arrowhead-${t}" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto">
      <polygon points="0 0, 8 3, 0 6" fill="${col}" fill-opacity="0.7"/>
    </marker>`;
  }).join('');

  let edgeSVG = '', edgeLabelSVG = '';
  edges.forEach((e, ei) => {
    const pa = pos[e.from], pb = pos[e.to];
    if (!pa || !pb) return;
    const col = edgeColours[e.type] || edgeColours.default;
    // Slightly curved path
    const mx = (pa.x + pb.x) / 2, my = (pa.y + pb.y) / 2;
    const dx = pb.x - pa.x, dy = pb.y - pa.y;
    const len = Math.sqrt(dx*dx + dy*dy) || 1;
    const bend = 20;
    const qx = mx - dy/len * bend, qy = my + dx/len * bend;
    edgeSVG += `<path class="map-edge" data-from="${e.from}" data-to="${e.to}" data-ei="${ei}"
      d="M${pa.x.toFixed(1)},${pa.y.toFixed(1)} Q${qx.toFixed(1)},${qy.toFixed(1)} ${pb.x.toFixed(1)},${pb.y.toFixed(1)}"
      stroke="${col}" stroke-opacity="0.35" stroke-width="1.5" fill="none"
      marker-end="url(#arrowhead-${e.type || 'default'})"/>`;
    if (e.label) {
      edgeLabelSVG += `<text class="map-edge-label" data-ei="${ei}"
        x="${qx.toFixed(1)}" y="${(qy - 4).toFixed(1)}"
        text-anchor="middle" dominant-baseline="middle"
        font-family="DM Sans, sans-serif" font-size="9" fill="${col}" fill-opacity="0.75"
        style="pointer-events:none">${esc(e.label)}</text>`;
    }
  });

  let nodeSVG = '';
  nodes.forEach(n => {
    const p = pos[n.id];
    if (!p) return;
    const tc = typeColours[n.type] || typeColours.supporting;
    const lines = wrapLabel(n.label);
    const lineH = 13;
    const totalH = lines.length * lineH;
    // Connected edge indices for focus
    const connEdges = edges.map((e,i) => (e.from===n.id||e.to===n.id) ? i : -1).filter(i=>i>=0).join(',');
    const connNodes = [...new Set(edges.flatMap(e => e.from===n.id ? [e.to] : e.to===n.id ? [e.from] : []))].join(',');

    nodeSVG += `<g class="map-node" tabindex="0" role="button"
        data-id="${n.id}" data-type="${n.type}"
        data-label="${esc(n.label)}" data-summary="${esc(n.summary)}"
        data-conn-edges="${connEdges}" data-conn-nodes="${connNodes}"
        transform="translate(${p.x.toFixed(1)},${p.y.toFixed(1)})"
        aria-label="${esc(n.label)}: ${esc(n.summary)}">
      <ellipse rx="${tc.r}" ry="${tc.r * 0.68}"
        fill="${tc.fill}" stroke="${tc.stroke}" stroke-width="1.5"
        filter="url(#node-glow)"/>
      ${lines.map((l, i) =>
        `<text text-anchor="middle"
          y="${(-totalH/2 + i*lineH + lineH*0.4).toFixed(1)}"
          font-family="DM Sans, sans-serif"
          font-size="${n.type === 'core' ? 11 : 10}"
          font-weight="${n.type === 'core' ? 600 : 500}"
          fill="${tc.text}" style="pointer-events:none">${esc(l)}</text>`
      ).join('')}
    </g>`;
  });

  const svgContent = `<svg id="concept-svg" viewBox="0 0 ${svgW} ${svgH}"
       xmlns="http://www.w3.org/2000/svg" style="display:block;width:100%;min-height:480px">
    <defs>
      ${defs}
      <filter id="node-glow">
        <feGaussianBlur stdDeviation="3" result="blur"/>
        <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
      </filter>
      <filter id="bg-blur"><feGaussianBlur stdDeviation="40"/></filter>
    </defs>
    <rect width="${svgW}" height="${svgH}" fill="#12121f"/>
    <circle cx="${cx}" cy="${cy}" r="220" fill="#003865" opacity="0.07" filter="url(#bg-blur)"/>
    <g id="map-viewport">
      ${edgeSVG}
      ${edgeLabelSVG}
      ${nodeSVG}
    </g>
  </svg>`;

  showStage(`
    <div class="concept-map-wrap activity-content">
      <div class="map-header">
        <div class="map-title">🕸 ${esc(title)}</div>
        <div class="map-controls">
          <button class="btn-map-ctrl" id="btn-map-reset" title="Reset zoom &amp; pan">⊡ Reset</button>
          <button class="btn-map-ctrl" id="btn-map-focus-clear" title="Clear selection" style="display:none">✕ Clear</button>
        </div>
      </div>
      <div class="map-body">
        <div id="concept-svg-container">
          ${svgContent}
          <div class="map-zoom-btns">
            <button class="btn-zoom" id="btn-zoom-in" title="Zoom in">+</button>
            <button class="btn-zoom" id="btn-zoom-out" title="Zoom out">−</button>
          </div>
          <div class="map-zoom-hint">Scroll to zoom · Drag to pan · Click node to focus</div>
        </div>
        <div class="map-detail-panel" id="map-detail-panel">
          <div class="map-detail-inner" id="map-detail-inner"></div>
        </div>
      </div>
      <div class="map-legend" id="map-legend">
        <span class="legend-item filter-active" data-type="core"><span class="legend-dot" style="background:#f5a623"></span>Core</span>
        <span class="legend-item filter-active" data-type="supporting"><span class="legend-dot" style="background:#00d4aa"></span>Supporting</span>
        <span class="legend-item filter-active" data-type="process"><span class="legend-dot" style="background:#a78bfa"></span>Process</span>
        <span class="legend-item filter-active" data-type="example"><span class="legend-dot" style="background:#38bdf8"></span>Example</span>
      </div>
    </div>`);

  wireConceptMap(data, edges, pos, typeColours);
}

function wireConceptMap(data, edges, pos, typeColours) {
  const container = document.getElementById('concept-svg-container');
  const viewport  = document.getElementById('map-viewport');
  const detailPanel = document.getElementById('map-detail-panel');
  const detailInner = document.getElementById('map-detail-inner');
  const tip       = document.getElementById('node-tooltip');
  const tipTitle  = document.getElementById('tt-title');
  const tipBody   = document.getElementById('tt-body');
  const edgeColours = {
    causes: '#fb7185', leads_to: '#f5a623', is_a: '#00d4aa',
    part_of: '#38bdf8', contrasts_with: '#a78bfa',
    requires: '#fdc85a', produces: '#00d4aa', default: '#888899',
  };

  // ── Zoom / Pan state ─────────────────────────────────────────
  let vx = 0, vy = 0, vscale = 1;
  let isPanning = false, panStart = null, panOrigin = null;
  const MIN_SCALE = 0.3, MAX_SCALE = 3;

  function applyViewport() {
    viewport.setAttribute('transform', `translate(${vx},${vy}) scale(${vscale})`);
  }

  // Mouse wheel zoom
  container.addEventListener('wheel', e => {
    e.preventDefault();
    const rect = container.getBoundingClientRect();
    const mx = e.clientX - rect.left, my = e.clientY - rect.top;
    const delta = e.deltaY > 0 ? 0.88 : 1.14;
    const newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, vscale * delta));
    // Zoom toward mouse pointer
    vx = mx - (mx - vx) * (newScale / vscale);
    vy = my - (my - vy) * (newScale / vscale);
    vscale = newScale;
    applyViewport();
  }, { passive: false });

  // Drag-to-pan
  container.addEventListener('pointerdown', e => {
    if (e.target.closest('.map-node') || e.target.closest('.btn-zoom')) return;
    isPanning = true;
    container.classList.add('panning');
    container.setPointerCapture(e.pointerId);
    panStart = { x: e.clientX, y: e.clientY };
    panOrigin = { x: vx, y: vy };
  });
  container.addEventListener('pointermove', e => {
    if (!isPanning) return;
    vx = panOrigin.x + (e.clientX - panStart.x);
    vy = panOrigin.y + (e.clientY - panStart.y);
    applyViewport();
  });
  container.addEventListener('pointerup', () => {
    isPanning = false;
    container.classList.remove('panning');
  });

  // Zoom buttons
  document.getElementById('btn-zoom-in').addEventListener('click', () => {
    vscale = Math.min(MAX_SCALE, vscale * 1.2);
    applyViewport();
  });
  document.getElementById('btn-zoom-out').addEventListener('click', () => {
    vscale = Math.max(MIN_SCALE, vscale / 1.2);
    applyViewport();
  });

  // Reset button
  document.getElementById('btn-map-reset').addEventListener('click', () => {
    vx = 0; vy = 0; vscale = 1;
    applyViewport();
    clearFocus();
  });

  // ── Drag nodes ───────────────────────────────────────────────
  let draggingNode = null, dragOffset = { x: 0, y: 0 };

  function getSVGPoint(clientX, clientY) {
    const rect = container.getBoundingClientRect();
    return {
      x: (clientX - rect.left - vx) / vscale,
      y: (clientY - rect.top  - vy) / vscale,
    };
  }

  function redrawEdges() {
    document.querySelectorAll('.map-edge').forEach(path => {
      const from = path.dataset.from, to = path.dataset.to;
      const pa = pos[from], pb = pos[to];
      if (!pa || !pb) return;
      const mx = (pa.x + pb.x) / 2, my = (pa.y + pb.y) / 2;
      const dx = pb.x - pa.x, dy = pb.y - pa.y;
      const len = Math.sqrt(dx*dx+dy*dy) || 1;
      const bend = 20;
      const qx = mx - dy/len*bend, qy = my + dx/len*bend;
      path.setAttribute('d', `M${pa.x.toFixed(1)},${pa.y.toFixed(1)} Q${qx.toFixed(1)},${qy.toFixed(1)} ${pb.x.toFixed(1)},${pb.y.toFixed(1)}`);
      // Reposition label
      const ei = path.dataset.ei;
      const lbl = document.querySelector(`.map-edge-label[data-ei="${ei}"]`);
      if (lbl) { lbl.setAttribute('x', qx.toFixed(1)); lbl.setAttribute('y', (qy-4).toFixed(1)); }
    });
  }

  document.querySelectorAll('.map-node').forEach(g => {
    g.addEventListener('pointerdown', e => {
      e.stopPropagation();
      draggingNode = g;
      g.setPointerCapture(e.pointerId);
      const svgPt = getSVGPoint(e.clientX, e.clientY);
      const id = g.dataset.id;
      dragOffset = { x: svgPt.x - pos[id].x, y: svgPt.y - pos[id].y };
    });
    g.addEventListener('pointermove', e => {
      if (draggingNode !== g) return;
      e.stopPropagation();
      const svgPt = getSVGPoint(e.clientX, e.clientY);
      const id = g.dataset.id;
      pos[id].x = svgPt.x - dragOffset.x;
      pos[id].y = svgPt.y - dragOffset.y;
      g.setAttribute('transform', `translate(${pos[id].x.toFixed(1)},${pos[id].y.toFixed(1)})`);
      redrawEdges();
    });
    g.addEventListener('pointerup', e => {
      draggingNode = null;
    });
  });

  // ── Hover: tooltip + edge highlight ─────────────────────────
  let hoverTimeout = null;

  document.querySelectorAll('.map-node').forEach(g => {
    g.addEventListener('mouseenter', e => {
      if (draggingNode) return;
      clearTimeout(hoverTimeout);
      tipTitle.textContent = g.dataset.label;
      tipBody.textContent = g.dataset.summary;
      tip.style.left = (e.clientX + 14) + 'px';
      tip.style.top  = (e.clientY - 10) + 'px';
      tip.classList.add('visible');

      // Highlight connected edges
      const connEdgeIdxs = new Set((g.dataset.connEdges || '').split(',').filter(Boolean));
      document.querySelectorAll('.map-edge').forEach(el => {
        el.classList.toggle('highlighted', connEdgeIdxs.has(el.dataset.ei));
      });
      document.querySelectorAll('.map-edge-label').forEach(el => {
        el.classList.toggle('highlighted', connEdgeIdxs.has(el.dataset.ei));
      });
    });
    g.addEventListener('mousemove', e => {
      tip.style.left = (e.clientX + 14) + 'px';
      tip.style.top  = (e.clientY - 10) + 'px';
    });
    g.addEventListener('mouseleave', () => {
      hoverTimeout = setTimeout(() => { tip.classList.remove('visible'); }, 80);
      document.querySelectorAll('.map-edge, .map-edge-label').forEach(el => el.classList.remove('highlighted'));
    });
  });

  // ── Click: focus node + show detail panel ────────────────────
  let focusedId = null;

  function clearFocus() {
    focusedId = null;
    document.querySelectorAll('.map-node').forEach(n => n.classList.remove('focused','dimmed','neighbour'));
    document.querySelectorAll('.map-edge, .map-edge-label').forEach(el => el.classList.remove('dimmed','highlighted'));
    detailPanel.classList.remove('open');
    document.getElementById('btn-map-focus-clear').style.display = 'none';
  }

  function focusNode(g) {
    const id = g.dataset.id;
    if (focusedId === id) { clearFocus(); return; }
    focusedId = id;

    const connNodeIds = new Set((g.dataset.connNodes || '').split(',').filter(Boolean));
    const connEdgeIdxs = new Set((g.dataset.connEdges || '').split(',').filter(Boolean));

    document.querySelectorAll('.map-node').forEach(n => {
      n.classList.remove('focused','dimmed','neighbour');
      if (n.dataset.id === id) n.classList.add('focused');
      else if (connNodeIds.has(n.dataset.id)) n.classList.add('neighbour');
      else n.classList.add('dimmed');
    });
    document.querySelectorAll('.map-edge').forEach(el => {
      el.classList.remove('dimmed','highlighted');
      if (connEdgeIdxs.has(el.dataset.ei)) el.classList.add('highlighted');
      else el.classList.add('dimmed');
    });
    document.querySelectorAll('.map-edge-label').forEach(el => {
      el.classList.remove('dimmed','highlighted');
      if (connEdgeIdxs.has(el.dataset.ei)) el.classList.add('highlighted');
      else el.classList.add('dimmed');
    });

    // Build connections list for detail panel
    const nodeType = g.dataset.type || 'supporting';
    const typeClr = { core:'#f5a623', supporting:'#00d4aa', process:'#a78bfa', example:'#38bdf8' };
    const clr = typeClr[nodeType] || '#888';

    const conns = edges
      .filter(e => e.from === id || e.to === id)
      .map(e => {
        const otherId = e.from === id ? e.to : e.from;
        const otherNode = data.nodes.find(n => n.id === otherId);
        const dir = e.from === id ? '→' : '←';
        return { label: otherNode?.label || otherId, rel: `${dir} ${e.label || e.type}`, col: edgeColours[e.type] || edgeColours.default };
      });

    detailInner.innerHTML = `
      <button class="map-detail-close" id="map-detail-close" aria-label="Close detail panel">✕</button>
      <div class="map-detail-type" style="color:${clr}">${nodeType}</div>
      <div class="map-detail-name">${esc(g.dataset.label)}</div>
      <div class="map-detail-summary">${esc(g.dataset.summary)}</div>
      ${conns.length ? `
        <div class="map-detail-connections">
          <div class="map-detail-conn-label">Connections (${conns.length})</div>
          ${conns.map(c => `
            <div class="map-detail-conn-item">
              <span>${esc(c.label)}</span>
              <span class="map-detail-conn-rel" style="color:${c.col}">${esc(c.rel)}</span>
            </div>`).join('')}
        </div>` : ''}`;

    detailPanel.classList.add('open');
    document.getElementById('btn-map-focus-clear').style.display = '';
    document.getElementById('map-detail-close').addEventListener('click', clearFocus);
  }

  document.querySelectorAll('.map-node').forEach(g => {
    // Click to focus (but not if we just dragged)
    let pointerDownPos = null;
    g.addEventListener('pointerdown', e => { pointerDownPos = { x: e.clientX, y: e.clientY }; });
    g.addEventListener('pointerup', e => {
      if (!pointerDownPos) return;
      const dx = e.clientX - pointerDownPos.x, dy = e.clientY - pointerDownPos.y;
      if (Math.sqrt(dx*dx+dy*dy) < 5) focusNode(g); // only if not dragged
      pointerDownPos = null;
    });
    // Keyboard
    g.addEventListener('keydown', e => {
      if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); focusNode(g); }
      if (e.key === 'Escape') clearFocus();
    });
  });

  document.getElementById('btn-map-focus-clear').addEventListener('click', clearFocus);

  // Click on background to clear focus
  document.getElementById('concept-svg').addEventListener('click', e => {
    if (!e.target.closest('.map-node')) clearFocus();
  });

  // ── Legend filter ────────────────────────────────────────────
  const hiddenTypes = new Set();

  document.querySelectorAll('#map-legend .legend-item').forEach(item => {
    item.addEventListener('click', () => {
      const type = item.dataset.type;
      if (hiddenTypes.has(type)) {
        hiddenTypes.delete(type);
        item.classList.remove('filter-off');
        item.classList.add('filter-active');
      } else {
        hiddenTypes.add(type);
        item.classList.add('filter-off');
        item.classList.remove('filter-active');
      }
      document.querySelectorAll('.map-node').forEach(n => {
        n.style.display = hiddenTypes.has(n.dataset.type) ? 'none' : '';
      });
    });
  });

  // ── Keyboard nav: Tab cycles through nodes ───────────────────
  // (handled natively via tabindex="0" on each .map-node g element)
}

// ══════════════════════════════════════════════════════════
//  ACTIVITY 2: SOCRATIC TUTOR
// ══════════════════════════════════════════════════════════

async function startSocratic(text) {
  const obj = getObjective();
  showGenerating('Preparing your Socratic tutor — Claude is reading the text and formulating opening questions…');

  // System prompt for the tutor
  const systemPrompt = `You are a Socratic tutor. Your student has just read the following OER excerpt:

---
${text}
---
${obj ? `\nFocus area: ${obj}` : ''}

YOUR RULES (never break them):
1. NEVER give the student direct answers or explanations. Only ask questions.
2. Your questions must lead the student to discover the answer themselves.
3. If a student answer is wrong or incomplete, ask a question that gently redirects.
4. If a student answer is correct, affirm briefly and deepen with another question.
5. Questions should be concise (1–3 sentences). Never lecture.
6. Vary your Socratic techniques: definition questions ("What do you mean by X?"), counter-examples ("What if the opposite were true?"), cause-effect ("What would happen if...?"), assumption-surfacing ("What are you assuming when you say...?").
7. After 6–8 exchanges, synthesise by asking the student to state the key insight themselves.

Start with a genuinely interesting opening question about the text — not something with an obvious answer.`;

  // First tutor message
  const opening = await callClaude('Begin the Socratic dialogue with your opening question.', systemPrompt);

  state.socraticHistory = [
    { role: 'system', content: systemPrompt },
    { role: 'assistant', content: opening },
  ];
  state.socraticReady = true;

  showStage(`
    <div class="socratic-wrap activity-content">
      <div class="socratic-messages" id="socratic-messages">
        <div class="message tutor">
          <div class="msg-avatar" aria-hidden="true">🦉</div>
          <div>
            <div class="msg-label">Socratic Tutor</div>
            <div class="msg-bubble">${esc(opening)}</div>
          </div>
        </div>
      </div>
      <div class="socratic-input-area">
        <textarea class="student-textarea" id="student-input"
          placeholder="Think it through… type your response here. There are no wrong answers — only deeper questions."
          rows="2" aria-label="Your response"></textarea>
        <button class="btn-send" id="btn-send" type="button">Reply →</button>
      </div>
      <div class="socratic-hint">The tutor will never simply tell you the answer. That's the point. 🦉</div>
    </div>`);

  const ta = document.getElementById('student-input');
  ta.addEventListener('keydown', e => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      socraticReply();
    }
  });
  document.getElementById('btn-send').addEventListener('click', socraticReply);
  setGenerateDisabled(false);
}

async function socraticReply() {
  const input = document.getElementById('student-input');
  const btn = document.getElementById('btn-send');
  const userText = input.value.trim();
  if (!userText) return;

  input.value = '';
  btn.disabled = true;

  const msgs = document.getElementById('socratic-messages');

  // Append student message
  msgs.innerHTML += `
    <div class="message student">
      <div class="msg-avatar" aria-hidden="true">🧑‍🎓</div>
      <div>
        <div class="msg-label">You</div>
        <div class="msg-bubble">${esc(userText)}</div>
      </div>
    </div>`;

  // Thinking indicator
  const thinkId = 'thinking-' + Date.now();
  msgs.innerHTML += `
    <div class="message tutor" id="${thinkId}">
      <div class="msg-avatar" aria-hidden="true">🦉</div>
      <div>
        <div class="msg-label">Socratic Tutor</div>
        <div class="msg-bubble"><div class="thinking-dots"><span></span><span></span><span></span></div></div>
      </div>
    </div>`;
  msgs.scrollTop = msgs.scrollHeight;

  state.socraticHistory.push({ role: 'user', content: userText });

  try {
    // Build full conversation for the prompt
    const convoLines = state.socraticHistory
      .filter(m => m.role !== 'system')
      .map(m => `${m.role === 'assistant' ? 'TUTOR' : 'STUDENT'}: ${m.content}`)
      .join('\n\n');

    const fullPrompt = `${state.socraticHistory[0].content}\n\nConversation so far:\n${convoLines}\n\nSTUDENT: ${userText}\n\nTUTOR (respond with a Socratic question only):`;

    const tutorReply = await callClaude(fullPrompt);
    state.socraticHistory.push({ role: 'assistant', content: tutorReply });

    // Replace thinking indicator
    const thinkEl = document.getElementById(thinkId);
    if (thinkEl) {
      thinkEl.querySelector('.msg-bubble').textContent = tutorReply;
    }
  } catch (err) {
    const thinkEl = document.getElementById(thinkId);
    if (thinkEl) thinkEl.querySelector('.msg-bubble').textContent = '(Error: ' + err.message + ')';
  }

  msgs.scrollTop = msgs.scrollHeight;
  btn.disabled = false;
  input.focus();
}

// ══════════════════════════════════════════════════════════
//  ACTIVITY 3: EVIDENCE TRIBUNAL
// ══════════════════════════════════════════════════════════

async function generateTribunal(text) {
  const obj = getObjective();
  showGenerating('Identifying a central claim from your OER and marshalling evidence on both sides…');

  const prompt = `You are a critical thinking exercise designer. Analyse this OER text and create an Evidence Tribunal activity.

OER TEXT:
---
${text}
---
${obj ? `\nFocus: ${obj}` : ''}

Return ONLY valid JSON (no markdown):
{
  "claim": "A substantive, debatable claim drawn from or implied by the text (1–2 sentences)",
  "context": "Brief context for why this claim matters (1 sentence)",
  "for": [
    { "id": "f1", "argument": "A specific piece of evidence or reasoning that SUPPORTS the claim, drawn from the text or its logical implications", "source": "brief description of where this comes from in the text", "strength": 75 },
    { "id": "f2", "argument": "...", "source": "...", "strength": 60 },
    { "id": "f3", "argument": "...", "source": "...", "strength": 85 }
  ],
  "against": [
    { "id": "a1", "argument": "A specific piece of evidence or reasoning that CHALLENGES the claim — could be a counterexample, limitation, or alternative interpretation", "source": "...", "strength": 70 },
    { "id": "a2", "argument": "...", "source": "...", "strength": 55 },
    { "id": "a3", "argument": "...", "source": "...", "strength": 80 }
  ],
  "reflection_prompt": "A question to guide the student's verdict (1 sentence)"
}

The claim must be genuinely debatable — not obviously true or false. Strengths are 1–100.`;

  const raw = await callClaude(prompt);
  const data = parseJSON(raw);
  state.generatedData = data;
  renderTribunal(data);
  setGenerateDisabled(false);
}

function renderTribunal(data) {
  const forArgs = data.for.map(a => `
    <div class="argument-card for" data-id="${esc(a.id)}" data-side="for">
      <div class="arg-text">${esc(a.argument)}</div>
      <div class="arg-source">Source: ${esc(a.source)}</div>
      <div class="arg-strength-bar for">
        <div class="arg-strength-fill for" style="width:${a.strength}%"></div>
      </div>
    </div>`).join('');

  const againstArgs = data.against.map(a => `
    <div class="argument-card against" data-id="${esc(a.id)}" data-side="against">
      <div class="arg-text">${esc(a.argument)}</div>
      <div class="arg-source">Source: ${esc(a.source)}</div>
      <div class="arg-strength-bar against">
        <div class="arg-strength-fill against" style="width:${a.strength}%"></div>
      </div>
    </div>`).join('');

  showStage(`
    <div class="tribunal-wrap activity-content">
      <div class="tribunal-claim">
        <div class="claim-label">⚖️ The Claim Before the Tribunal</div>
        <div class="claim-text">"${esc(data.claim)}"</div>
        ${data.context ? `<div style="font-size:0.78rem;color:var(--text-dim);margin-top:10px;">${esc(data.context)}</div>` : ''}
      </div>

      <div style="font-size:0.78rem;color:var(--text-dim);text-align:center;margin:-4px 0;">
        Read all arguments. You are the judge — weigh the evidence and deliver your verdict below.
      </div>

      <div class="tribunal-arena">
        <div class="for-side">
          <div class="side-header for">Arguments In Favour</div>
          ${forArgs}
        </div>
        <div class="tribunal-vs">
          <div class="vs-circle">vs</div>
        </div>
        <div class="against-side">
          <div class="side-header against">Arguments Against</div>
          ${againstArgs}
        </div>
      </div>

      <div class="verdict-zone">
        <div class="verdict-title">Your Verdict</div>
        <div class="verdict-scale">
          <span class="scale-label for">Strongly agree</span>
          <input type="range" class="verdict-slider" id="verdict-slider" min="0" max="100" value="50"
                 aria-label="Verdict strength slider">
          <span class="scale-label against">Strongly disagree</span>
        </div>
        <div class="verdict-live-label" id="verdict-live-label">Undecided</div>
        <p style="font-size:0.78rem;color:var(--text-dim);margin-bottom:10px;">${esc(data.reflection_prompt || 'Explain your reasoning:')}</p>
        <textarea class="verdict-reasoning" id="verdict-reasoning"
          placeholder="Explain your reasoning. Which arguments did you find most compelling and why? What would change your mind?"
          rows="3"></textarea>
        <button class="btn-deliver-verdict" id="btn-deliver" type="button">⚖️ Deliver Verdict</button>
        <div id="verdict-result-area"></div>
      </div>
    </div>`);

  document.getElementById('btn-deliver').addEventListener('click', deliverVerdict);

  // Live slider label
  const slider = document.getElementById('verdict-slider');
  const liveLabel = document.getElementById('verdict-live-label');
  function updateSliderLabel() {
    const v = parseInt(slider.value);
    let text, color;
    if (v <= 20)      { text = 'Strongly agree';     color = 'var(--teal)'; }
    else if (v <= 40) { text = 'Leaning agree';      color = 'rgba(0,212,170,0.7)'; }
    else if (v <= 60) { text = 'Undecided';          color = 'var(--text-dim)'; }
    else if (v <= 80) { text = 'Leaning disagree';   color = 'rgba(251,113,133,0.7)'; }
    else              { text = 'Strongly disagree';  color = 'var(--rose)'; }
    liveLabel.textContent = text;
    liveLabel.style.color = color;
  }
  slider.addEventListener('input', updateSliderLabel);
  updateSliderLabel();
}

async function deliverVerdict() {
  const slider = document.getElementById('verdict-slider');
  const reasoning = document.getElementById('verdict-reasoning').value.trim();
  const btn = document.getElementById('btn-deliver');
  const resultArea = document.getElementById('verdict-result-area');

  if (!reasoning) {
    resultArea.innerHTML = `<div class="verdict-result" style="border-color:rgba(251,113,133,0.4)">
      <div class="verdict-result-title" style="color:var(--rose)">Please provide your reasoning first.</div>
    </div>`;
    return;
  }

  btn.disabled = true;
  btn.textContent = 'Considering your verdict…';

  const sliderVal = parseInt(slider.value);
  const stance = sliderVal < 40 ? 'strongly disagrees with' : sliderVal > 60 ? 'strongly agrees with' : 'is undecided about';
  const data = state.generatedData;

  try {
    const prompt = `A student was presented with this claim: "${data.claim}"

They were given evidence on both sides and then rendered a verdict. The student ${stance} the claim.

Their reasoning: "${reasoning}"

Respond as a thoughtful professor. In 3–4 sentences:
1. Acknowledge what is insightful in their reasoning
2. Point out one thing they may have overlooked or could examine more deeply
3. End with a question that invites further reflection

Be direct, engaged, and intellectually challenging. Do not repeat the claim verbatim.`;

    const feedback = await callClaude(prompt);
    resultArea.innerHTML = `<div class="verdict-result">
      <div class="verdict-result-title">Professor's Response</div>
      <div class="verdict-result-body">${esc(feedback)}</div>
    </div>`;
  } catch (err) {
    resultArea.innerHTML = `<div class="verdict-result">
      <div class="verdict-result-title" style="color:var(--rose)">Error: ${esc(err.message)}</div>
    </div>`;
  }

  btn.disabled = false;
  btn.textContent = '⚖️ Revise Verdict';
}

// ══════════════════════════════════════════════════════════
//  ACTIVITY 4: ANALOGY FORGE
// ══════════════════════════════════════════════════════════

async function generateAnalogy(text) {
  const obj = getObjective();
  showGenerating('Forging an analogy — Claude is finding a bridge between your OER and something from everyday experience…');

  const prompt = `You are a master of analogical reasoning in education. Analyse this OER excerpt and create an Analogy Forge activity.

OER TEXT:
---
${text}
---
${obj ? `\nFocus: ${obj}` : ''}

Return ONLY valid JSON (no markdown):
{
  "source_concept": {
    "name": "The academic concept from the OER (2–5 words)",
    "description": "What it is and how it works, from the text (2–3 sentences)"
  },
  "analogy_concept": {
    "name": "An everyday concept that works as an analogy (e.g. a recipe, a traffic jam, a river fork, a musical band)",
    "description": "Brief description of the analogy concept (1–2 sentences)"
  },
  "mappings": [
    { "source": "element from the OER concept", "analogy": "corresponding element in the analogy", "relation": "how they correspond" },
    { "source": "...", "analogy": "...", "relation": "..." },
    { "source": "...", "analogy": "...", "relation": "..." },
    { "source": "...", "analogy": "...", "relation": "..." }
  ],
  "extend_prompt": "Ask the student to extend the analogy — find ONE more mapping that isn't listed above",
  "break_prompt": "Ask the student where the analogy BREAKS DOWN — what is fundamentally different about the real concept that the analogy fails to capture?",
  "rebuild_prompt": "Ask the student to propose a BETTER analogy, or modify this one to fix the flaw they identified"
}

The analogy must be genuinely illuminating, not trivial. Choose something surprising but apt.`;

  const raw = await callClaude(prompt);
  const data = parseJSON(raw);
  state.generatedData = data;
  renderAnalogy(data);
  setGenerateDisabled(false);
}

function renderAnalogy(data) {
  const mappingRows = data.mappings.map(m => `
    <div class="forge-mapping-row">
      <div class="forge-mapping-cell">${esc(m.source)}</div>
      <div class="forge-mapping-connector">↔</div>
      <div class="forge-mapping-cell">${esc(m.analogy)}</div>
    </div>`).join('');

  showStage(`
    <div class="forge-wrap activity-content">

      <div class="forge-concept-row">
        <div class="forge-concept-box source">
          <div class="forge-box-label">OER Concept</div>
          <div class="forge-concept-title">${esc(data.source_concept.name)}</div>
          <div class="forge-concept-desc">${esc(data.source_concept.description)}</div>
        </div>
        <div class="forge-arrow">↔</div>
        <div class="forge-concept-box analogy">
          <div class="forge-box-label">Analogy</div>
          <div class="forge-concept-title">${esc(data.analogy_concept.name)}</div>
          <div class="forge-concept-desc">${esc(data.analogy_concept.description)}</div>
        </div>
      </div>

      <div>
        <div style="font-size:0.65rem;font-weight:700;letter-spacing:0.1em;text-transform:uppercase;color:var(--text-dim);margin-bottom:8px;">Concept Mappings</div>
        <div class="forge-mappings">
          <div class="forge-mapping-row" style="background:var(--surface-hi)">
            <div class="forge-mapping-cell" style="font-size:0.62rem;font-weight:700;letter-spacing:0.08em;text-transform:uppercase;color:var(--text-dim)">In the OER concept…</div>
            <div class="forge-mapping-connector"></div>
            <div class="forge-mapping-cell" style="font-size:0.62rem;font-weight:700;letter-spacing:0.08em;text-transform:uppercase;color:var(--text-dim)">…is like in the analogy</div>
          </div>
          ${mappingRows}
        </div>
      </div>

      <div class="forge-tasks">

        <div class="forge-task extend">
          <div class="forge-task-label">① Extend</div>
          <div class="forge-task-prompt">${esc(data.extend_prompt)}</div>
          <textarea class="forge-response" id="forge-extend" placeholder="Find one more mapping the list didn't include…" rows="2"></textarea>
          <button class="btn-forge-check" data-task="extend" type="button">Get feedback →</button>
          <div class="forge-feedback hidden" id="feedback-extend"></div>
        </div>

        <div class="forge-task break-it">
          <div class="forge-task-label">② Break It</div>
          <div class="forge-task-prompt">${esc(data.break_prompt)}</div>
          <textarea class="forge-response" id="forge-break" placeholder="Where does this analogy fail? What does it miss or distort?" rows="2"></textarea>
          <button class="btn-forge-check" data-task="break" type="button">Get feedback →</button>
          <div class="forge-feedback hidden" id="feedback-break"></div>
        </div>

        <div class="forge-task rebuild">
          <div class="forge-task-label">③ Rebuild</div>
          <div class="forge-task-prompt">${esc(data.rebuild_prompt)}</div>
          <textarea class="forge-response" id="forge-rebuild" placeholder="Propose a better analogy or patch the flaw you found…" rows="2"></textarea>
          <button class="btn-forge-check" data-task="rebuild" type="button">Get feedback →</button>
          <div class="forge-feedback hidden" id="feedback-rebuild"></div>
        </div>

      </div>
    </div>`);

  document.querySelectorAll('.btn-forge-check').forEach(btn => {
    btn.addEventListener('click', () => forgeFeedback(btn.dataset.task));
  });
}

async function forgeFeedback(task) {
  const textarea = document.getElementById(`forge-${task}`);
  const feedbackEl = document.getElementById(`feedback-${task}`);
  const response = textarea?.value.trim();
  if (!response) return;

  const btn = document.querySelector(`[data-task="${task}"]`);
  btn.disabled = true;
  btn.textContent = 'Thinking…';

  const data = state.generatedData;
  const prompts = {
    extend: `The student was given this analogy: "${data.source_concept.name}" is like "${data.analogy_concept.name}". They were asked to extend the analogy by finding one more mapping. They wrote: "${response}". Evaluate their extension in 2–3 sentences: is it a valid mapping? What's insightful about it? If wrong, guide them toward a better extension without giving it away.`,
    break: `The student was given this analogy: "${data.source_concept.name}" is like "${data.analogy_concept.name}". They were asked where the analogy breaks down. They wrote: "${response}". Respond in 2–3 sentences: is their critique valid? What did they get right? What might they be missing about the analogy's limits?`,
    rebuild: `The student identified a flaw in the analogy and proposed a fix or new analogy. They wrote: "${response}". Respond in 2–3 sentences: is their new analogy or patch an improvement? What does it capture better? What does it still miss?`,
  };

  try {
    const feedback = await callClaude(prompts[task]);
    feedbackEl.textContent = feedback;
    feedbackEl.classList.remove('hidden');
  } catch (err) {
    feedbackEl.textContent = 'Error: ' + err.message;
    feedbackEl.classList.remove('hidden');
  }

  btn.disabled = false;
  btn.textContent = 'Update feedback →';
}

// ══════════════════════════════════════════════════════════
//  ACTIVITY 5: CONCEPT TIMELINE
// ══════════════════════════════════════════════════════════

async function generateTimeline(text) {
  const obj = getObjective();
  showGenerating('Mapping the development or sequence of ideas in your OER…');

  const prompt = `You are an educational designer creating a Concept Timeline activity. This is not a historical timeline — it traces the CONCEPTUAL or LOGICAL sequence in which ideas build on each other in the text.

OER TEXT:
---
${text}
---
${obj ? `\nFocus: ${obj}` : ''}

Return ONLY valid JSON (no markdown):
{
  "title": "Short title describing what this timeline traces",
  "type": "logical|historical|procedural|developmental",
  "items": [
    {
      "era": "Stage/Step label (e.g. 'Foundation', 'Step 1', 'Early', 'Before')",
      "concept": "Name of the concept at this stage (3–6 words)",
      "detail": "What happens or is understood at this stage — from the text (1–2 sentences)",
      "reveals_on_click": "A deeper question or implication the student should think about (1 sentence)",
      "connections": ["id of another item this connects to"]
    }
  ],
  "synthesis_question": "A final question asking the student to explain the whole sequence in their own words"
}

Create 5–8 items that trace a genuinely meaningful progression. Each item must build logically on the last.
'era' labels should be vivid: use descriptive language, not just numbers.`;

  const raw = await callClaude(prompt);
  const data = parseJSON(raw);
  state.generatedData = data;
  renderTimeline(data);
  setGenerateDisabled(false);
}

function renderTimeline(data) {
  const { title, type, items, synthesis_question } = data;

  const typeLabel = { logical: 'Logical Sequence', historical: 'Historical Progression', procedural: 'Step-by-Step Process', developmental: 'Development Arc' }[type] || type;

  const itemsHTML = items.map((item, i) => {
    const isLeft = i % 2 === 0;
    return `
      <div class="timeline-item" style="animation-delay:${i * 0.08}s">
        ${isLeft ? `
          <div class="timeline-card" data-idx="${i}" data-revealed="false"
               id="tl-card-${i}" tabindex="0" role="button"
               aria-label="Click to reveal more about ${esc(item.concept)}">
            <div class="card-concept">${esc(item.concept)}</div>
            <div class="card-detail">${esc(item.detail)}</div>
            <div class="card-hidden-prompt" id="tl-hidden-${i}">→ Click to go deeper</div>
          </div>
          <div class="timeline-node">
            <div class="timeline-dot"></div>
            <div class="timeline-era">${esc(item.era)}</div>
          </div>
          <div class="timeline-card-empty"></div>
        ` : `
          <div class="timeline-card-empty"></div>
          <div class="timeline-node">
            <div class="timeline-dot"></div>
            <div class="timeline-era">${esc(item.era)}</div>
          </div>
          <div class="timeline-card" data-idx="${i}" data-revealed="false"
               id="tl-card-${i}" tabindex="0" role="button"
               aria-label="Click to reveal more about ${esc(item.concept)}">
            <div class="card-concept">${esc(item.concept)}</div>
            <div class="card-detail">${esc(item.detail)}</div>
            <div class="card-hidden-prompt" id="tl-hidden-${i}">→ Click to go deeper</div>
          </div>
        `}
      </div>`;
  }).join('');

  showStage(`
    <div class="timeline-wrap activity-content">
      <div style="display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:8px">
        <div style="font-family:'Fraunces',serif;font-size:1.1rem;font-weight:600;color:var(--text)">📍 ${esc(title)}</div>
        <div style="font-size:0.68rem;font-weight:700;letter-spacing:0.08em;text-transform:uppercase;color:var(--rose);border:1px solid rgba(251,113,133,0.3);padding:3px 10px;border-radius:20px;">${esc(typeLabel)}</div>
      </div>

      <div class="timeline-intro">
        Click each concept card to reveal a deeper question. The axis shows the logical order ideas develop.
      </div>

      <div class="timeline-track">
        <div class="timeline-axis" aria-hidden="true"></div>
        <div class="timeline-items">
          ${itemsHTML}
        </div>
      </div>

      <div class="timeline-question-box" id="tl-synthesis" style="display:none">
        <div class="tq-label">🔗 Synthesis Challenge</div>
        <div class="tq-prompt">${esc(synthesis_question)}</div>
        <textarea class="tq-input" id="tl-synthesis-input"
          placeholder="Write your synthesis here…" rows="3"></textarea>
        <button class="btn-reveal" id="btn-get-synthesis-feedback" type="button">Get AI feedback</button>
        <div id="synthesis-feedback" style="margin-top:12px;font-size:0.83rem;color:var(--text);line-height:1.6;display:none"></div>
      </div>
    </div>`);

  wireTimeline(data);
}

let revealedCount = 0;

function wireTimeline(data) {
  revealedCount = 0;

  document.querySelectorAll('.timeline-card').forEach(card => {
    card.addEventListener('click', () => revealTimelineCard(card, data));
    card.addEventListener('keydown', e => {
      if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); revealTimelineCard(card, data); }
    });
  });

  document.getElementById('btn-get-synthesis-feedback')?.addEventListener('click', getSynthesisFeedback);
}

async function revealTimelineCard(card, data) {
  const idx = parseInt(card.dataset.idx);
  const item = data.items[idx];
  if (card.dataset.revealed === 'true') return;

  card.dataset.revealed = 'true';
  card.classList.add('revealed');

  // Replace the "click" hint with the deep question
  const hiddenEl = document.getElementById(`tl-hidden-${idx}`);
  if (hiddenEl) {
    hiddenEl.innerHTML = `<div style="margin-top:8px;padding:8px 10px;background:var(--panel);border-radius:6px;border:1px solid rgba(56,189,248,0.25)">
      <div style="font-size:0.58rem;font-weight:700;letter-spacing:0.08em;text-transform:uppercase;color:var(--sky);margin-bottom:4px">Think about this</div>
      <div style="font-size:0.8rem;color:var(--text);line-height:1.5">${esc(item.reveals_on_click)}</div>
    </div>`;
  }

  revealedCount++;
  // Show synthesis after half revealed
  if (revealedCount >= Math.ceil(data.items.length / 2)) {
    const synth = document.getElementById('tl-synthesis');
    if (synth) synth.style.display = '';
  }
}

async function getSynthesisFeedback() {
  const input = document.getElementById('tl-synthesis-input').value.trim();
  const fb = document.getElementById('synthesis-feedback');
  const btn = document.getElementById('btn-get-synthesis-feedback');
  if (!input) return;

  btn.disabled = true;
  btn.textContent = 'Reading…';
  fb.textContent = '';
  fb.style.display = 'none';

  const data = state.generatedData;
  try {
    const prompt = `A student was given a concept timeline about "${data.title}" and asked: "${data.synthesis_question}"

They wrote: "${input}"

Respond as a knowledgeable tutor. In 3–4 sentences: what did they capture well? What is missing or could be more precise? End with one further question to deepen their thinking. Be warm but intellectually demanding.`;

    const feedback = await callClaude(prompt);
    fb.textContent = feedback;
    fb.style.display = 'block';
  } catch (err) {
    fb.textContent = 'Error: ' + err.message;
    fb.style.display = 'block';
  }

  btn.disabled = false;
  btn.textContent = 'Update feedback';
}

// ══════════════════════════════════════════════════════════
//  ASSUMPTION EXCAVATOR
// ══════════════════════════════════════════════════════════

async function generateAssumptions(text) {
  const obj = getObjective();
  showGenerating('Excavating the assumptions embedded in this text — what does it take for granted?');

  const prompt = `You are an expert in critical reading and ideology critique. Analyse this OER excerpt and identify the hidden assumptions embedded in it — things the author treats as obviously true, natural, or uncontested, but which are actually contestable.

OER TEXT:
----
${text}
----
${obj ? `\nFocus: ${obj}` : ''}

Return ONLY valid JSON (no markdown):
{
  "title": "Short title describing what is being examined",
  "preamble": "One sentence explaining why identifying assumptions matters for this text",
  "assumptions": [
    {
      "id": "a1",
      "text": "The specific assumption, stated clearly (1–2 sentences). Start with 'This text assumes that...' or 'The author takes for granted that...'",
      "type": "empirical|normative|conceptual|political",
      "why_hidden": "Why a reader might not notice this assumption (1 sentence)",
      "challenge_prompt": "A question that asks the student to defend OR challenge this assumption with reasoning or evidence (1 sentence)"
    }
  ]
}

Types: "empirical" = assumed fact; "normative" = assumed value or 'ought'; "conceptual" = assumed definition or category; "political" = assumed distribution of power or interest.
Produce 4–6 assumptions. Make them genuinely substantive — not surface-level observations, but deep structural assumptions that shape what the text can and cannot say.`;

  const raw = await callClaude(prompt);
  const data = parseJSON(raw);
  state.generatedData = data;
  renderAssumptions(data);
  setGenerateDisabled(false);
}

function renderAssumptions(data) {
  const typeColors = {
    empirical:   { color: 'var(--sky)',    bg: 'rgba(56,189,248,0.12)',  border: 'rgba(56,189,248,0.3)'  },
    normative:   { color: 'var(--rose)',   bg: 'rgba(251,113,133,0.12)', border: 'rgba(251,113,133,0.3)' },
    conceptual:  { color: 'var(--violet)', bg: 'rgba(167,139,250,0.12)', border: 'rgba(167,139,250,0.3)' },
    political:   { color: 'var(--gold)',   bg: 'rgba(245,166,35,0.12)',  border: 'rgba(245,166,35,0.3)'  },
  };

  const cardsHTML = data.assumptions.map((a, i) => {
    const tc = typeColors[a.type] || typeColors.conceptual;
    return `
      <div class="assume-card" id="assume-card-${i}">
        <div class="assume-card-head">
          <div class="assume-num">${i + 1}</div>
          <div class="assume-text">${esc(a.text)}</div>
          <div class="assume-type-badge" style="color:${tc.color};background:${tc.bg};border-color:${tc.border}">${esc(a.type)}</div>
        </div>
        <div style="font-size:0.77rem;color:var(--text-dim);padding:6px 10px;background:var(--panel);border-radius:6px;border-left:2px solid ${tc.color}">
          <strong style="color:var(--text-dim);font-size:0.62rem;letter-spacing:0.06em;text-transform:uppercase">Why it's hidden: </strong>${esc(a.why_hidden)}
        </div>
        <div class="assume-rating">
          <div class="assume-rating-label">Do you agree with this assumption?</div>
          <div class="assume-stars" id="stars-${i}" data-idx="${i}" aria-label="Rate your agreement">
            <button class="assume-star" data-val="1" title="Strongly disagree" aria-label="Strongly disagree">✗</button>
            <button class="assume-star" data-val="2" title="Lean disagree" aria-label="Lean disagree">?</button>
            <button class="assume-star" data-val="3" title="Neutral / unsure" aria-label="Neutral">–</button>
            <button class="assume-star" data-val="4" title="Lean agree" aria-label="Lean agree">~</button>
            <button class="assume-star" data-val="5" title="Strongly agree" aria-label="Strongly agree">✓</button>
          </div>
        </div>
        <div class="assume-response-area" id="assume-response-${i}">
          <div class="assume-response-prompt">${esc(a.challenge_prompt)}</div>
          <textarea class="assume-textarea" id="assume-text-${i}"
            placeholder="Write your response here — defend it, challenge it, or complicate it…" rows="3"></textarea>
          <button class="btn-assume-check" data-idx="${i}" type="button">Get feedback →</button>
          <div class="assume-feedback" id="assume-feedback-${i}" style="display:none"></div>
        </div>
      </div>`;
  }).join('');

  showStage(`
    <div class="assume-wrap activity-content">
      <div class="assume-intro">
        <strong style="color:var(--violet)">🔍 Assumption Excavator</strong> — Every text is built on assumptions its author treats as obvious.
        Rate your agreement with each one, then write a response to the question that follows.
        ${data.preamble ? `<br><br>${esc(data.preamble)}` : ''}
      </div>
      ${cardsHTML}
    </div>`);

  // Wire star buttons
  document.querySelectorAll('.assume-stars').forEach(starsEl => {
    const idx = parseInt(starsEl.dataset.idx);
    starsEl.querySelectorAll('.assume-star').forEach(starBtn => {
      starBtn.addEventListener('click', () => {
        const val = parseInt(starBtn.dataset.val);
        starsEl.querySelectorAll('.assume-star').forEach(s => s.classList.toggle('selected', parseInt(s.dataset.val) === val));
        // Show response area whenever they rate
        const responseArea = document.getElementById(`assume-response-${idx}`);
        if (responseArea) responseArea.classList.add('show');
      });
    });
  });

  // Wire feedback buttons
  document.querySelectorAll('.btn-assume-check').forEach(btn => {
    btn.addEventListener('click', () => assumptionFeedback(parseInt(btn.dataset.idx)));
  });
}

async function assumptionFeedback(idx) {
  const data = state.generatedData;
  const assumption = data.assumptions[idx];
  const textarea = document.getElementById(`assume-text-${idx}`);
  const fbEl = document.getElementById(`assume-feedback-${idx}`);
  const btn = document.querySelector(`.btn-assume-check[data-idx="${idx}"]`);
  const response = textarea?.value.trim();
  if (!response) return;

  btn.disabled = true;
  btn.textContent = 'Reading…';
  fbEl.style.display = 'none';

  try {
    const prompt = `A student read an OER text and was asked to respond to this assumption:

ASSUMPTION: "${assumption.text}"
CHALLENGE PROMPT: "${assumption.challenge_prompt}"

STUDENT RESPONSE: "${response}"

Respond as a thoughtful tutor in 3–4 sentences. Acknowledge what is strong or insightful in their response. Identify one gap, complication, or counterargument they haven't considered. End with one further question that pushes their thinking deeper. Be intellectually challenging but encouraging.`;

    const feedback = await callClaude(prompt);
    fbEl.textContent = feedback;
    fbEl.style.display = 'block';
  } catch (err) {
    fbEl.textContent = 'Error: ' + err.message;
    fbEl.style.display = 'block';
  }

  btn.disabled = false;
  btn.textContent = 'Update feedback';
}

// ══════════════════════════════════════════════════════════
//  TRANSFER CHALLENGE
// ══════════════════════════════════════════════════════════

async function generateTransfer(text) {
  const obj = getObjective();
  showGenerating('Finding contexts where this idea shows up beyond the text — building transfer scenarios…');

  const prompt = `You are an educational designer creating a Transfer Challenge activity. The goal is to help students apply a key concept from an OER text to novel real-world contexts they must reason through themselves.

OER TEXT:
----
${text}
----
${obj ? `\nFocus: ${obj}` : ''}

Return ONLY valid JSON (no markdown):
{
  "concept": {
    "name": "The central concept to transfer (3–6 words)",
    "description": "What this concept means and how it works, from the text (2–3 sentences)",
    "core_logic": "The essential logic or mechanism — the part that must survive transfer (1 sentence)"
  },
  "scenarios": [
    {
      "id": "s1",
      "domain": "The domain this scenario is drawn from (e.g. 'Medicine', 'Sport', 'Parenting')",
      "icon": "A single emoji that represents this domain",
      "situation": "A concrete real-world situation (2–3 sentences) — enough detail to reason about",
      "guiding_question": "How does [concept name] apply here, and where does it break down? (1 sentence, specific to this scenario)"
    }
  ],
  "apply_prompt": "Ask the student to choose one scenario and explain how the concept applies — step by step — being specific about which elements of the concept map onto which elements of the scenario",
  "breakdown_prompt": "Ask the student where the concept does NOT transfer cleanly — what is different about this scenario that complicates or limits the concept?",
  "insight_prompt": "Ask what the process of transferring the concept has revealed about the concept itself — what did applying it to a new context teach them about its assumptions or limits?"
}

Generate exactly 3 scenarios from very different domains (e.g. not two healthcare scenarios). Make scenarios concrete and specific enough that students can actually reason through them. The scenarios should be genuinely challenging — not obvious applications.`;

  const raw = await callClaude(prompt);
  const data = parseJSON(raw);
  state.generatedData = data;
  renderTransfer(data);
  setGenerateDisabled(false);
}

function renderTransfer(data) {
  const scenariosHTML = data.scenarios.map((s, i) => `
    <div class="transfer-scenario" data-idx="${i}" tabindex="0" role="button"
         aria-pressed="false" aria-label="Select scenario: ${esc(s.domain)}">
      <div class="transfer-scenario-icon">${esc(s.icon)}</div>
      <div class="transfer-scenario-body">
        <div class="transfer-scenario-domain">${esc(s.domain)}</div>
        <div class="transfer-scenario-situation">${esc(s.situation)}</div>
        <div class="transfer-scenario-question">${esc(s.guiding_question)}</div>
      </div>
    </div>`).join('');

  showStage(`
    <div class="transfer-wrap activity-content">

      <div class="transfer-concept-box">
        <div class="transfer-concept-label">Concept to Transfer</div>
        <div class="transfer-concept-name">${esc(data.concept.name)}</div>
        <div class="transfer-concept-desc">${esc(data.concept.description)}</div>
        <div style="margin-top:8px;padding:7px 10px;background:var(--panel);border-radius:6px;border-left:2px solid var(--teal)">
          <span style="font-size:0.62rem;font-weight:700;letter-spacing:0.06em;text-transform:uppercase;color:var(--teal)">Core logic: </span>
          <span style="font-size:0.8rem;color:var(--text)">${esc(data.concept.core_logic)}</span>
        </div>
      </div>

      <div>
        <div class="transfer-scenarios-label" style="margin-bottom:10px">Choose a scenario to work through:</div>
        <div class="transfer-scenarios">${scenariosHTML}</div>
      </div>

      <div class="transfer-work-area" id="transfer-work" style="display:none">
        <div class="transfer-work-title">🌐 Your Transfer Work</div>

        <div class="transfer-task">
          <div class="transfer-task-prompt" id="transfer-apply-prompt">${esc(data.apply_prompt)}</div>
          <textarea class="transfer-textarea" id="transfer-apply-input"
            placeholder="Explain step by step how the concept maps onto your chosen scenario…" rows="4"></textarea>
          <button class="btn-transfer-check" id="btn-transfer-apply" type="button">Get feedback →</button>
          <div class="transfer-feedback" id="transfer-apply-feedback" style="display:none"></div>
        </div>

        <hr style="border:none;border-top:1px solid var(--border);margin:4px 0">

        <div class="transfer-task">
          <div class="transfer-task-prompt">${esc(data.breakdown_prompt)}</div>
          <textarea class="transfer-textarea" id="transfer-break-input"
            placeholder="Where does the concept NOT transfer cleanly? What is different here?" rows="3"></textarea>
          <button class="btn-transfer-check" id="btn-transfer-break" type="button">Get feedback →</button>
          <div class="transfer-feedback" id="transfer-break-feedback" style="display:none"></div>
        </div>

        <hr style="border:none;border-top:1px solid var(--border);margin:4px 0">

        <div class="transfer-task">
          <div class="transfer-task-prompt">${esc(data.insight_prompt)}</div>
          <textarea class="transfer-textarea" id="transfer-insight-input"
            placeholder="What did applying this concept to a new context reveal about the concept itself?" rows="3"></textarea>
          <button class="btn-transfer-check" id="btn-transfer-insight" type="button">Get feedback →</button>
          <div class="transfer-feedback" id="transfer-insight-feedback" style="display:none"></div>
        </div>
      </div>

    </div>`);

  // Wire scenario selection
  let selectedScenario = null;
  document.querySelectorAll('.transfer-scenario').forEach(el => {
    const activate = () => {
      document.querySelectorAll('.transfer-scenario').forEach(s => { s.classList.remove('selected'); s.setAttribute('aria-pressed', 'false'); });
      el.classList.add('selected');
      el.setAttribute('aria-pressed', 'true');
      selectedScenario = data.scenarios[parseInt(el.dataset.idx)];
      document.getElementById('transfer-work').style.display = '';
    };
    el.addEventListener('click', activate);
    el.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); activate(); } });
  });

  // Wire feedback buttons
  [
    { btnId: 'btn-transfer-apply',   inputId: 'transfer-apply-input',   fbId: 'transfer-apply-feedback',   task: 'apply'   },
    { btnId: 'btn-transfer-break',   inputId: 'transfer-break-input',   fbId: 'transfer-break-feedback',   task: 'break'   },
    { btnId: 'btn-transfer-insight', inputId: 'transfer-insight-input', fbId: 'transfer-insight-feedback', task: 'insight' },
  ].forEach(({ btnId, inputId, fbId, task }) => {
    document.getElementById(btnId)?.addEventListener('click', () =>
      transferFeedback(task, inputId, fbId, btnId, () => selectedScenario));
  });
}

async function transferFeedback(task, inputId, fbId, btnId, getScenario) {
  const data = state.generatedData;
  const scenario = getScenario();
  const input = document.getElementById(inputId)?.value.trim();
  const fbEl = document.getElementById(fbId);
  const btn = document.getElementById(btnId);
  if (!input) return;

  btn.disabled = true;
  btn.textContent = 'Reading…';
  fbEl.style.display = 'none';

  try {
    const scenarioDesc = scenario
      ? `The student chose the scenario: "${scenario.domain}" — "${scenario.situation}"`
      : 'The student chose a scenario from the activity.';

    const taskDescriptions = {
      apply:   'explain step by step how the concept applies to their chosen scenario',
      break:   'identify where the concept does NOT transfer cleanly — the limits and complications',
      insight: 'reflect on what the transfer process revealed about the concept itself',
    };

    const prompt = `A student is doing a Transfer Challenge activity based on this OER concept: "${data.concept.name}" — "${data.concept.core_logic}"

${scenarioDesc}

Their task was to ${taskDescriptions[task]}.

STUDENT RESPONSE: "${input}"

Respond as a knowledgeable tutor in 3–4 sentences. Acknowledge the strongest part of their response. Point out something important they missed or could push further. End with one question that takes their thinking one step deeper. Be direct, intellectually serious, and encouraging.`;

    const feedback = await callClaude(prompt);
    fbEl.textContent = feedback;
    fbEl.style.display = 'block';
  } catch (err) {
    fbEl.textContent = 'Error: ' + err.message;
    fbEl.style.display = 'block';
  }

  btn.disabled = false;
  btn.textContent = 'Update feedback';
}

// ══════════════════════════════════════════════════════════
//  QUESTION GENERATOR
// ══════════════════════════════════════════════════════════

async function generateQuestions(text) {
  const obj = getObjective();
  showGenerating('Generating expert-level questions across different types — then it\'s your turn to add yours…');

  const prompt = `You are an expert educator. Analyse this OER excerpt and generate a rich set of questions that model expert-level question formation. The goal is to teach students the skill of asking good questions, not just answering them.

OER TEXT:
----
${text}
----
${obj ? `\nFocus: ${obj}` : ''}

Return ONLY valid JSON (no markdown):
{
  "title": "Short title for this question set",
  "categories": [
    {
      "type": "clarification",
      "label": "Clarification",
      "description": "Questions that probe meaning, definition, or precision",
      "color_key": "sky",
      "questions": ["question 1", "question 2"]
    },
    {
      "type": "implication",
      "label": "Implication",
      "description": "Questions that ask what follows if the text is correct",
      "color_key": "teal",
      "questions": ["question 1", "question 2"]
    },
    {
      "type": "evaluation",
      "label": "Evaluation",
      "description": "Questions that assess the quality, evidence, or fairness of claims",
      "color_key": "rose",
      "questions": ["question 1", "question 2"]
    },
    {
      "type": "research_gap",
      "label": "Research Gap",
      "description": "Questions the text raises but does not answer — genuine unknowns",
      "color_key": "gold",
      "questions": ["question 1", "question 2"]
    }
  ],
  "student_prompt": "An invitation asking the student to add 2–3 of their own questions — any type — then star the ones they find most worth pursuing (1–2 sentences)"
}

Generate exactly 2 questions per category — 8 questions total. Make them genuinely interesting and specific to this text, not generic academic questions. Research gap questions especially should be things where the answer is actually unknown or contested.`;

  const raw = await callClaude(prompt);
  const data = parseJSON(raw);
  state.generatedData = data;
  renderQuestions(data);
  setGenerateDisabled(false);
}

function renderQuestions(data) {
  const colorMap = {
    sky:    { color: 'var(--sky)',    bg: 'rgba(56,189,248,0.10)',  border: 'rgba(56,189,248,0.25)',  dot: '#38bdf8' },
    teal:   { color: 'var(--teal)',   bg: 'rgba(0,212,170,0.10)',   border: 'rgba(0,212,170,0.25)',   dot: '#00d4aa' },
    rose:   { color: 'var(--rose)',   bg: 'rgba(251,113,133,0.10)', border: 'rgba(251,113,133,0.25)', dot: '#fb7185' },
    gold:   { color: 'var(--gold)',   bg: 'rgba(245,166,35,0.10)',  border: 'rgba(245,166,35,0.25)',  dot: '#f5a623' },
    violet: { color: 'var(--violet)', bg: 'rgba(167,139,250,0.10)', border: 'rgba(167,139,250,0.25)', dot: '#a78bfa' },
  };

  let allQuestions = []; // track for rationale list

  const categoriesHTML = data.categories.map(cat => {
    const cm = colorMap[cat.color_key] || colorMap.sky;
    const qHTML = cat.questions.map((q, qi) => {
      const qid = `q-${cat.type}-${qi}`;
      allQuestions.push({ id: qid, text: q, type: cat.type });
      return `
        <div class="qgen-question" id="${qid}" data-qid="${qid}" data-starred="false">
          <div class="qgen-question-text">${esc(q)}</div>
          <button class="qgen-star-btn" aria-label="Star this question" title="Star this question">☆</button>
        </div>`;
    }).join('');

    return `
      <div class="qgen-category">
        <div class="qgen-category-label" style="color:${cm.color}">
          <div class="qgen-category-dot" style="background:${cm.dot}"></div>
          ${esc(cat.label)}
          <span style="font-size:0.6rem;font-weight:400;text-transform:none;letter-spacing:0;color:var(--text-dim);margin-left:4px">— ${esc(cat.description)}</span>
        </div>
        ${qHTML}
      </div>`;
  }).join('');

  showStage(`
    <div class="qgen-wrap activity-content">

      <div class="qgen-intro">
        <strong style="color:var(--gold)">❓ Question Generator</strong> — Here are eight expert-level questions generated from the text, across four types.
        Star the ones you find most worth pursuing. Then add your own questions below, and write a rationale for your top pick.
      </div>

      <div style="display:flex;align-items:baseline;gap:8px;flex-wrap:wrap">
        <div style="font-family:'Fraunces',serif;font-size:1rem;font-weight:600;color:var(--text)">${esc(data.title)}</div>
      </div>

      ${categoriesHTML}

      <div class="qgen-add-section">
        <div class="qgen-add-label">✍ Your Questions</div>
        <div class="qgen-add-prompt">${esc(data.student_prompt)}</div>
        <textarea class="qgen-add-textarea" id="qgen-add-input"
          placeholder="Write your own questions here, one per line…" rows="4"></textarea>
        <button class="btn-qgen-add" id="btn-qgen-add" type="button">Add my questions</button>
        <div id="qgen-student-questions"></div>
      </div>

      <div class="qgen-rationale-section" id="qgen-rationale-section">
        <div class="qgen-rationale-label">⭐ Why That Question?</div>
        <div class="qgen-rationale-prompt" id="qgen-rationale-prompt">
          Star the question you find most worth pursuing above, then explain your reasoning here.
        </div>
        <textarea class="qgen-rationale-textarea" id="qgen-rationale-input"
          placeholder="Why is this question worth pursuing? What would it take to answer it? What might the answer change?" rows="4"></textarea>
        <button class="btn-qgen-submit" id="btn-qgen-submit" type="button">Get feedback on your rationale</button>
        <div class="qgen-feedback" id="qgen-rationale-feedback" style="display:none"></div>
      </div>

    </div>`);

  // Wire star buttons
  let starredQuestion = null;
  document.querySelectorAll('.qgen-question').forEach(qEl => {
    const starBtn = qEl.querySelector('.qgen-star-btn');
    starBtn.addEventListener('click', () => {
      const isNowStarred = qEl.dataset.starred === 'false';
      // Unstar all
      document.querySelectorAll('.qgen-question').forEach(q => {
        q.classList.remove('starred');
        q.dataset.starred = 'false';
        q.querySelector('.qgen-star-btn').textContent = '☆';
      });
      if (isNowStarred) {
        qEl.classList.add('starred');
        qEl.dataset.starred = 'true';
        starBtn.textContent = '★';
        starredQuestion = qEl.querySelector('.qgen-question-text').textContent;
        // Update rationale prompt
        const rp = document.getElementById('qgen-rationale-prompt');
        if (rp) rp.textContent = `You starred: "${starredQuestion.slice(0, 100)}${starredQuestion.length > 100 ? '…' : ''}" — why is this question most worth pursuing?`;
      } else {
        starredQuestion = null;
        const rp = document.getElementById('qgen-rationale-prompt');
        if (rp) rp.textContent = 'Star the question you find most worth pursuing above, then explain your reasoning here.';
      }
    });
  });

  // Wire "Add my questions" button
  document.getElementById('btn-qgen-add')?.addEventListener('click', () => {
    const raw = document.getElementById('qgen-add-input').value.trim();
    if (!raw) return;
    const lines = raw.split('\n').map(l => l.trim()).filter(Boolean);
    const container = document.getElementById('qgen-student-questions');
    lines.forEach((line, i) => {
      const qid = `q-student-${Date.now()}-${i}`;
      const div = document.createElement('div');
      div.className = 'qgen-question';
      div.id = qid;
      div.dataset.starred = 'false';
      div.innerHTML = `
        <div class="qgen-question-text" style="color:var(--gold)">${esc(line)}</div>
        <button class="qgen-star-btn" aria-label="Star this question" title="Star this question">☆</button>`;
      div.querySelector('.qgen-star-btn').addEventListener('click', () => {
        const isNowStarred = div.dataset.starred === 'false';
        document.querySelectorAll('.qgen-question').forEach(q => {
          q.classList.remove('starred'); q.dataset.starred = 'false';
          q.querySelector('.qgen-star-btn').textContent = '☆';
        });
        if (isNowStarred) {
          div.classList.add('starred'); div.dataset.starred = 'true';
          div.querySelector('.qgen-star-btn').textContent = '★';
          starredQuestion = line;
          const rp = document.getElementById('qgen-rationale-prompt');
          if (rp) rp.textContent = `You starred: "${line.slice(0, 100)}${line.length > 100 ? '…' : ''}" — why is this question most worth pursuing?`;
        } else {
          starredQuestion = null;
        }
      });
      container.appendChild(div);
    });
    document.getElementById('qgen-add-input').value = '';
  });

  // Wire rationale submit
  document.getElementById('btn-qgen-submit')?.addEventListener('click', async () => {
    const rationale = document.getElementById('qgen-rationale-input').value.trim();
    const fbEl = document.getElementById('qgen-rationale-feedback');
    const btn = document.getElementById('btn-qgen-submit');
    if (!rationale) return;

    btn.disabled = true;
    btn.textContent = 'Reading…';
    fbEl.style.display = 'none';

    try {
      const chosenQ = starredQuestion || '(no question starred)';
      const prompt = `A student completed a Question Generator activity on an OER text. From a set of questions about "${data.title}", they chose to pursue this question:

"${chosenQ}"

Their rationale for choosing it:
"${rationale}"

Respond as a knowledgeable tutor in 3–4 sentences. Affirm the strengths of their reasoning — what makes this a good question to pursue? Point out something they may not have considered about what it would take to answer it. End with a concrete suggestion: one source, method, or angle of inquiry they could actually follow up with. Be intellectually serious and practical.`;

      const feedback = await callClaude(prompt);
      fbEl.textContent = feedback;
      fbEl.style.display = 'block';
    } catch (err) {
      fbEl.textContent = 'Error: ' + err.message;
      fbEl.style.display = 'block';
    }

    btn.disabled = false;
    btn.textContent = 'Update feedback';
  });
}

// ══════════════════════════════════════════════════════════
//  INIT
// ══════════════════════════════════════════════════════════

function init() {

  // ── HASH DETECTION (synchronous — must run before async testConnection) ──
  const hashPayload = decodeShare(window.location.hash);
  if (hashPayload) {
    renderSharedActivity(hashPayload.activity, hashPayload.data);
  }

  // Activity tile clicks
  document.querySelectorAll('.activity-tile').forEach(tile => {
    tile.addEventListener('click', () => selectActivity(tile.dataset.activity));
  });

  // Connect button
  document.getElementById('btn-connect').addEventListener('click', testConnection);

  // Generate button
  document.getElementById('btn-generate').addEventListener('click', generate);

  // Regenerate button
  document.getElementById('btn-regenerate').addEventListener('click', generate);

  // Share button
  document.getElementById('btn-share').addEventListener('click', copyShareLink);

  // Save session button
  document.getElementById('btn-save').addEventListener('click', saveNovaSession);

  // Book search
  document.getElementById('book-search').addEventListener('input', e => {
    filterBooks(e.target.value);
  });

  // Retry books button
  document.getElementById('books-retry').addEventListener('click', loadBooks);

  // Back button (change book)
  document.getElementById('book-back').addEventListener('click', () => {
    state.bookUrl = null;
    state.bookTitle = null;
    state.chapterId = null;
    document.getElementById('book-focus-view').classList.add('hidden');
    document.getElementById('book-list-view').classList.remove('hidden');
    document.getElementById('chapter-notice').classList.add('hidden');
    const hasSource = state.sources.length > 0 || (document.getElementById('oer-text')?.value || '').trim();
    setGenerateDisabled(!hasSource || !state.connected);
  });

  // Part selector
  document.getElementById('part-select').addEventListener('change', onPartSelected);

  // Chapter selector
  document.getElementById('chapter-select').addEventListener('change', onChapterSelected);

  // Load chapter button
  document.getElementById('btn-load-chapter').addEventListener('click', loadChapter);

  // URL fetch button
  document.getElementById('btn-fetch-url').addEventListener('click', fetchUrl);
  document.getElementById('url-fetch-input').addEventListener('keydown', e => {
    if (e.key === 'Enter') fetchUrl();
  });

  // File upload button + hidden input
  document.getElementById('btn-file-upload').addEventListener('click', () => {
    document.getElementById('file-upload-input').click();
  });
  document.getElementById('file-upload-input').addEventListener('change', e => {
    const file = e.target.files?.[0];
    if (file) { handleFileUpload(file); e.target.value = ''; }
  });

  // Paste toggle
  document.getElementById('paste-toggle').addEventListener('click', () => {
    const section = document.getElementById('paste-section');
    const isOpen  = !section.classList.contains('hidden');
    if (isOpen) {
      // Close
      section.classList.add('hidden');
      document.getElementById('paste-toggle').classList.remove('active');
      document.getElementById('paste-toggle').textContent = '✎ Paste text instead';
      const note = document.getElementById('paste-auto-note');
      if (note) note.remove();
    } else {
      openPastePanel();
    }
  });

  // Word count on paste textarea
  const oerTextarea = document.getElementById('oer-text');
  oerTextarea.addEventListener('input', () => {
    const wc = wordCount(oerTextarea.value);
    document.getElementById('word-count').textContent = wc;
    const hasSource = state.sources.length > 0 || oerTextarea.value.trim();
    setGenerateDisabled(!hasSource || !state.connected);
  });

  // Proxy URL — reset connection state on change
  document.getElementById('proxy-url').addEventListener('change', () => {
    state.connected = false;
    state.allBooks = [];
    document.getElementById('status-pill').classList.remove('connected');
    document.getElementById('status-text').textContent = 'Not connected';
    // Reset book browser to loading state
    document.getElementById('books-ready').classList.add('hidden');
    document.getElementById('books-error').classList.add('hidden');
    document.getElementById('books-loading').classList.remove('hidden');
  });

  // Auto-connect on load (will trigger loadBooks() on success)
  testConnection();

  // Seed initial hint
  updateGenerateHint();

  // ── Mobile panel drawer ──────────────────────────────────────
  (function initMobilePanel() {
    const MQ = window.matchMedia('(max-width: 768px)');
    const panel    = document.querySelector('.context-panel');
    const btn      = document.getElementById('btn-open-panel');
    const backdrop = document.getElementById('mobile-backdrop');

    function open()  { panel.classList.add('mobile-open'); btn.setAttribute('aria-expanded','true'); backdrop.classList.add('visible'); }
    function close() { panel.classList.remove('mobile-open'); btn.setAttribute('aria-expanded','false'); backdrop.classList.remove('visible'); }
    function applyMobile(mobile) { btn.style.display = mobile ? 'flex' : 'none'; if (!mobile) close(); }

    btn.addEventListener('click', () => panel.classList.contains('mobile-open') ? close() : open());
    backdrop.addEventListener('click', close);
    MQ.addEventListener('change', e => applyMobile(e.matches));
    applyMobile(MQ.matches);
  })();
}

document.addEventListener('DOMContentLoaded', init);

// ── Suite-wide theme toggle ──────────────────────────────
(function() {
  var btn = document.getElementById('btn-suite-theme');
  if (!btn) return;
  function applyOmTheme(theme) {
    document.documentElement.setAttribute('data-theme', theme);
    btn.textContent = theme === 'dark' ? '☀' : '🌙';
    btn.title = theme === 'dark' ? 'Switch to light theme' : 'Switch to dark theme';
    try { localStorage.setItem('om-theme', theme); } catch(e) {}
  }
  btn.addEventListener('click', function() {
    var cur = document.documentElement.getAttribute('data-theme') || 'dark';
    applyOmTheme(cur === 'dark' ? 'light' : 'dark');
  });
  var cur = document.documentElement.getAttribute('data-theme') || 'dark';
  btn.textContent = cur === 'dark' ? '☀' : '🌙';
  btn.title = cur === 'dark' ? 'Switch to light theme' : 'Switch to dark theme';
})();
</script>
</body>
</html>
